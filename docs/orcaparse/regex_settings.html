<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orcaparse.regex_settings API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orcaparse.regex_settings</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os
import re
import warnings
from typing import Dict, List, Optional, Pattern, Union

from .regex_request import RegexRequest


class RegexBlueprint:
    def __init__(self, order: List[str], pattern_structure: Dict[str, str], pattern_texts: Dict[str, str], comment: str) -&gt; None:
        &#34;&#34;&#34;
        Initializes a RegexBlueprint instance, which serves as a template for generating RegexRequest objects.

        Args:
            order (List[str]): The ordered list of keys that defines the sequence of generated RegexRequest objects.
            pattern_structure (Dict[str, str]): A dictionary defining the common structure of regex patterns,
                including &#39;beginning&#39;, &#39;ending&#39;, and &#39;flags&#39; keys.
            pattern_texts (Dict[str, str]): A dictionary mapping each key in the &#39;order&#39; list to a specific
                text snippet to be inserted into the pattern structure.
            comment (str): A comment or description associated with this blueprint.
        &#34;&#34;&#34;
        self.order = order
        self.pattern_structure = pattern_structure
        self.pattern_texts = pattern_texts
        self.comment = comment
        self._initialize_items()

    def _initialize_items(self):
        self.items: dict[str, RegexRequest] = {}
        for name, text in self.pattern_texts.items():
            pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                       f&#34;{text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
            regex_request = RegexRequest(
                p_type=&#34;Block&#34;,
                p_subtype=name,
                pattern=pattern,
                flags=self.pattern_structure[&#39;flags&#39;],
                comment=self.comment
            )
            self.items[name] = regex_request

    def to_list(self) -&gt; List[RegexRequest]:
        &#34;&#34;&#34;
        Generates a list of RegexRequest objects based on the blueprint.

        Returns:
            List[RegexRequest]: A list of generated RegexRequest objects following the blueprint&#39;s structure.
        &#34;&#34;&#34;
        return [self.items[name] for name in self.order]

    def validate_configuration(self) -&gt; None:
        &#34;&#34;&#34;
        Validates the blueprint&#39;s configuration to ensure consistency and correctness.

        Raises:
            ValueError: If any configuration inconsistency or error is found.
        &#34;&#34;&#34;
        # Check if all items in &#39;order&#39; exist in &#39;pattern_texts&#39;
        for name in self.order:
            if name not in self.pattern_texts:
                raise ValueError(
                    f&#34;Item &#39;{name}&#39; in &#39;order&#39; does not have a corresponding entry in &#39;pattern_texts&#39;.&#34;)

        # Ensure &#39;pattern_structure&#39; contains required keys
        required_keys = [&#39;beginning&#39;, &#39;ending&#39;, &#39;flags&#39;]
        for key in required_keys:
            if key not in self.pattern_structure:
                raise ValueError(
                    f&#34;&#39;pattern_structure&#39; is missing the required key: &#39;{key}&#39;.&#34;)

        # Validate &#39;flags&#39; in &#39;pattern_structure&#39;
        valid_flags = {&#34;IGNORECASE&#34;, &#34;MULTILINE&#34;,
                       &#34;DOTALL&#34;, &#34;UNICODE&#34;, &#34;VERBOSE&#34;}
        for flag in self.pattern_structure[&#39;flags&#39;]:
            if flag not in valid_flags:
                raise ValueError(
                    f&#34;Invalid flag &#39;{flag}&#39; in &#39;pattern_structure&#39;. Valid flags are: {&#39;, &#39;.join(valid_flags)}.&#34;)

        # Validate that &#39;beginning&#39; + &#39;ending&#39; patterns are valid regex patterns
        try:
            re.compile(
                self.pattern_structure[&#39;beginning&#39;] + self.pattern_structure[&#39;ending&#39;])
        except re.error as e:
            raise ValueError(
                f&#34;Invalid regex pattern in &#39;pattern_structure&#39;: {e}&#34;)

        # Confirm comment is a string
        if not isinstance(self.comment, str):
            raise ValueError(&#34;&#39;comment&#39; must be a string.&#34;)

    def add_item(self, name: str, pattern_text: str) -&gt; None:
        &#34;&#34;&#34;
        Adds a new pattern text to the blueprint and its corresponding key to the order.

        Args:
            name (str): The key name for the new pattern text.
            pattern_text (str): The specific text snippet to be inserted into the pattern structure for this new item.
        &#34;&#34;&#34;
        self.pattern_texts[name] = pattern_text
        pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                   f&#34;{pattern_text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
        regex_request = RegexRequest(
            p_type=&#34;Block&#34;,
            p_subtype=name,
            pattern=pattern,
            flags=self.pattern_structure[&#39;flags&#39;],
            comment=self.comment
        )
        self.items[name] = regex_request
        self.order.append(name)
        self.validate_configuration()

    def to_dict(self) -&gt; Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]:
        &#34;&#34;&#34;
        Converts the RegexBlueprint instance into a dictionary representation.

        Returns:
            Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]: A dictionary representation of the RegexBlueprint.
        &#34;&#34;&#34;
        return {
            &#34;order&#34;: self.order,
            &#34;pattern_structure&#34;: self.pattern_structure,
            &#34;pattern_texts&#34;: self.pattern_texts,
            &#34;comment&#34;: self.comment
        }

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of items defined in the blueprint&#39;s order.

        Returns:
            int: The length of the &#39;order&#39; list.
        &#34;&#34;&#34;
        return len(self.order)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Provides a detailed string representation of the RegexBlueprint instance for debugging.

        Returns:
            str: A string representation including the order, pattern structure, pattern texts, and comment.
        &#34;&#34;&#34;
        return f&#34;RegexBlueprint(Order: {self.order}, Pattern Structure: {self.pattern_structure}, Pattern Texts: {self.pattern_texts}, Comment: {self.comment})&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the RegexBlueprint instance, using the tree method to illustrate the structure.

        Returns:
            str: A tree-like string representation of the blueprint.
        &#34;&#34;&#34;
        return self.tree()

    def tree(self, depth: int = 0) -&gt; str:
        &#34;&#34;&#34;
        Generates a string representation of the blueprint hierarchy in a tree-like structure. This method is useful
        for visualizing the blueprint&#39;s pattern structure, pattern texts, and their hierarchical relationships.

        Args:
            depth (int): The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.

        Returns:
            str: A string representation of the regex blueprint in a tree-like structure, showing nested patterns indented according to their depth.
        &#34;&#34;&#34;
        result = &#34;  &#34; * depth + &#34;RegexBlueprint:\n&#34;
        for name in self.order:
            text = self.pattern_texts.get(name, &#39;&#39;)
            pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                       f&#34;{text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
            result += &#34;  &#34; * (depth + 1) + f&#34;{name}: Pattern: {pattern}\n&#34;
        return result


class RegexSettings:
    def __init__(self, settings_file: Optional[str] = None, items: Optional[Dict[str, Union[RegexRequest, &#39;RegexSettings&#39;]]] = None, order: Optional[List[str]] = None) -&gt; None:
        &#34;&#34;&#34;
        Initializes a RegexSettings instance, which can either load settings from a file or be instantiated with provided items and order.

        Args:
            settings_file (Optional[str]): The path to a JSON file containing regex settings. If not provided, an empty or pre-defined configuration is used.
            items (Optional[Dict[str, Union[RegexRequest, &#39;RegexSettings&#39;]]]): A dictionary of items (RegexRequest objects or nested RegexSettings) keyed by their names.
            order (Optional[List[str]]): A list of item names specifying the order in which they should be processed.

        Raises:
            ValueError: If only one of items or order is provided, but not both.
        &#34;&#34;&#34;
        if items is None and order is None:
            if settings_file is not None:
                # Load from file
                self.items = {}
                self.order = []
                self.load_settings(settings_file)
            else:
                # Empty class
                self.items = {}
                self.order = []
        elif items is not None and order is not None:
            self.items = items
            self.order = order
        else:
            raise ValueError(
                &#34;Both &#39;items&#39; and &#39;order&#39; must be provided, or neither.&#34;)

        self.validate_configuration()

    def add_item(self, name: str, item: Union[RegexRequest, &#39;RegexSettings&#39;], rewrite: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Adds an item (RegexRequest or nested RegexSettings) to the settings.

        Args:
            name (str): The name/key associated with the item.
            item (Union[RegexRequest, &#39;RegexSettings&#39;]): The item to add, which can be a RegexRequest or another RegexSettings instance.
            rewrite (bool): Whether to overwrite an existing item with the same name. Defaults to False.

        Raises:
            ValueError: If the name already exists in the items.
        &#34;&#34;&#34;
        if name in self.items and not rewrite:
            raise ValueError(f&#34;Item with name &#39;{name}&#39; already exists.&#34;)
        self.items[name] = item
        if name not in self.order:
            self.order.append(name)
        self.validate_configuration()

    def set_order(self, order: List[str]) -&gt; None:
        &#34;&#34;&#34;
        Sets the order of items.

        Args:
            order (List[str]): A list of item names specifying the order.

        Raises:
            ValueError: If any name in the order list does not exist in the items.
        &#34;&#34;&#34;
        for name in order:
            if name not in self.items:
                raise ValueError(
                    f&#34;Item with name &#39;{name}&#39; does not exist in items.&#34;)
        self.order = order
        self.validate_configuration()

    def get_ordered_items(self) -&gt; List[Union[RegexRequest, &#39;RegexSettings&#39;]]:
        &#34;&#34;&#34;
        Returns a list of items in the specified order.

        Returns:
            List[Union[RegexRequest, &#39;RegexSettings&#39;]]: A list of ordered items.

        Raises:
            ValueError: If any name in the order list does not exist in the items.
        &#34;&#34;&#34;
        ordered_items = [self.items[name]
                         for name in self.order if name in self.items]
        if len(ordered_items) != len(self.order):
            missing_items = set(self.order) - set(self.items.keys())
            raise ValueError(
                f&#34;Missing items in &#39;items&#39;: {&#39;, &#39;.join(missing_items)}&#34;)
        return ordered_items

    def to_list(self) -&gt; List[Union[RegexRequest, &#39;RegexSettings&#39;]]:
        &#34;&#34;&#34;
        Flattens the items to a list, expanding nested RegexSettings into their constituent RegexRequest objects.

        Returns:
            List[Union[RegexRequest, &#39;RegexSettings&#39;]]: A flattened list of RegexRequest objects and/or RegexSettings instances.
        &#34;&#34;&#34;
        ordered_items = []
        for name in self.order:
            item = self.items[name]
            if isinstance(item, RegexRequest):
                ordered_items.append(item)
            elif isinstance(item, (RegexSettings, RegexBlueprint)):
                ordered_items.extend(item.to_list())
            else:
                raise TypeError(f&#34;Unknown type of item &#39;{name}&#39;: {type(item)}&#34;)
        return ordered_items

    def load_settings(self, settings_file: str) -&gt; None:
        &#34;&#34;&#34;
        Loads settings from a JSON file and populates the RegexSettings instance based on the file&#39;s content.

        Args:
            settings_file (str): The path to the JSON file containing the settings.
        &#34;&#34;&#34;
        with open(settings_file, &#34;r&#34;) as file:
            settings = json.load(file)
            self.parse_settings(settings)

    def parse_settings(self, settings: Dict[str, Union[Dict, List[str]]]) -&gt; None:
        &#34;&#34;&#34;
        Parses the given settings to populate this RegexSettings instance with
        RegexRequest objects, RegexBlueprint objects, or nested RegexSettings objects based on the settings structure.

        :param settings: The settings to parse, typically loaded from a JSON file.
        &#34;&#34;&#34;
        self.items: Dict[str, Union[RegexRequest,
                                    RegexBlueprint, &#39;RegexSettings&#39;]] = {}
        self.order = settings.get(&#39;order&#39;, [])

        for name in self.order:
            item_settings = settings[name]

            # Handling a direct RegexRequest (defined by a &#39;pattern&#39; key)
            if &#39;pattern&#39; in item_settings:
                request = RegexRequest(
                    p_type=item_settings[&#39;p_type&#39;],
                    p_subtype=item_settings[&#39;p_subtype&#39;],
                    pattern=item_settings[&#39;pattern&#39;],
                    flags=item_settings.get(&#39;flags&#39;, []),
                    comment=item_settings.get(&#39;comment&#39;, &#39;&#39;)
                )
                self.items[name] = request

            # Handling a RegexBlueprint (defined by a &#39;pattern_structure&#39; key)
            elif &#39;pattern_structure&#39; in item_settings:
                blueprint = RegexBlueprint(
                    order=item_settings[&#39;order&#39;],
                    pattern_structure=item_settings[&#39;pattern_structure&#39;],
                    pattern_texts=item_settings[&#39;pattern_texts&#39;],
                    comment=item_settings.get(&#39;comment&#39;, &#39;&#39;)
                )
                self.items[name] = blueprint

            # Handling nested RegexSettings
            else:
                # If the item is a nested structure but not a direct RegexRequest or Blueprint
                subgroup = RegexSettings()
                subgroup.parse_settings(item_settings)
                self.items[name] = subgroup

        # Validate the configuration after parsing
        self.validate_configuration()

    def tree(self, depth: int = 0) -&gt; str:
        &#34;&#34;&#34;
        Generates a string representation of the settings hierarchy in a tree-like structure.
        This method is useful for visualizing the nested structure of regex settings and blueprints.

        Args:
            depth (int): The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.

        Returns:
            str: A string representation of the regex settings in a tree-like structure, showing nested items indented according to their depth.
        &#34;&#34;&#34;
        result = &#34;  &#34; * depth + &#34;RegexGroup:\n&#34;
        for name in self.order:
            item = self.items[name]
            # If the item is a RegexSettings or RegexBlueprint, recursively call the tree method to represent its nested structure
            if isinstance(item, (RegexSettings, RegexBlueprint)):
                result += &#34;  &#34; * (depth + 1) + \
                    f&#34;{name}:\n&#34; + item.tree(depth + 2)
            # If the item is a RegexRequest, simply append its string representation
            else:
                result += &#34;  &#34; * (depth + 1) + f&#34;{name}: {item}\n&#34;
        return result

    def validate_configuration(self) -&gt; None:
        &#34;&#34;&#34;
        Validates the regex configuration to ensure consistency between &#39;order&#39; and &#39;items&#39;.
        Also recursively validates the configuration of nested RegexSettings instances.

        Raises:
            ValueError: If an item in &#39;order&#39; does not have a corresponding entry in &#39;items&#39;.

        Warns:
            RuntimeWarning: If there are keys in &#39;items&#39; not listed in &#39;order&#39;.
        &#34;&#34;&#34;
        # Check for items in &#39;order&#39; that are not in &#39;items&#39;
        for name in self.order:
            if name not in self.items:
                raise ValueError(
                    f&#34;Error: Item &#39;{name}&#39; listed in &#39;order&#39; but not found in &#39;items&#39;.&#34;)

        for name, item in self.items.items():
            item.validate_configuration()
            if name not in self.order:
                warnings.warn(
                    f&#34;Warning: Item &#39;{name}&#39; found in &#39;items&#39; but not listed in &#39;order&#39;.&#34;, RuntimeWarning)

    def to_dict(self) -&gt; Dict[str, Union[Dict, List[str]]]:
        &#34;&#34;&#34;Converts the RegexSettings instance and its nested structure to a dictionary.&#34;&#34;&#34;
        result = {&#34;order&#34;: self.order}
        for name in self.order:
            item = self.items[name]
            result[name] = item.to_dict() if isinstance(
                item, (RegexRequest, RegexSettings, RegexBlueprint)) else item
        return result

    def save_as_json(self, filename: str) -&gt; None:
        &#34;&#34;&#34;Saves the RegexSettings instance as a JSON file.&#34;&#34;&#34;
        with open(filename, &#39;w&#39;) as file:
            json.dump(self.to_dict(), file, indent=4)

    def __repr__(self) -&gt; str:
        return f&#34;RegexGroup(Order: {self.order}, Items: {list(self.items.keys())})&#34;

    def __len__(self) -&gt; str:
        return sum(len(item) for item in self.items.values())

    def __str__(self) -&gt; str:
        return self.tree()


DEFAULT_ORCA_REGEX_FILE = os.path.join(
    os.path.dirname(__file__), &#39;orca_regex.json&#39;)
DEFAULT_ORCA_REGEX_SETTINGS: RegexSettings = RegexSettings(
    settings_file=DEFAULT_ORCA_REGEX_FILE)

DEFAULT_GPAW_REGEX_FILE = os.path.join(
    os.path.dirname(__file__), &#39;gpaw_regex.json&#39;)
DEFAULT_GPAW_REGEX_SETTINGS: RegexSettings = RegexSettings(
    settings_file=DEFAULT_GPAW_REGEX_FILE)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orcaparse.regex_settings.RegexBlueprint"><code class="flex name class">
<span>class <span class="ident">RegexBlueprint</span></span>
<span>(</span><span>order: List[str], pattern_structure: Dict[str, str], pattern_texts: Dict[str, str], comment: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a RegexBlueprint instance, which serves as a template for generating RegexRequest objects.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The ordered list of keys that defines the sequence of generated RegexRequest objects.</dd>
<dt><strong><code>pattern_structure</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>A dictionary defining the common structure of regex patterns,
including 'beginning', 'ending', and 'flags' keys.</dd>
<dt><strong><code>pattern_texts</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>A dictionary mapping each key in the 'order' list to a specific
text snippet to be inserted into the pattern structure.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>A comment or description associated with this blueprint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexBlueprint:
    def __init__(self, order: List[str], pattern_structure: Dict[str, str], pattern_texts: Dict[str, str], comment: str) -&gt; None:
        &#34;&#34;&#34;
        Initializes a RegexBlueprint instance, which serves as a template for generating RegexRequest objects.

        Args:
            order (List[str]): The ordered list of keys that defines the sequence of generated RegexRequest objects.
            pattern_structure (Dict[str, str]): A dictionary defining the common structure of regex patterns,
                including &#39;beginning&#39;, &#39;ending&#39;, and &#39;flags&#39; keys.
            pattern_texts (Dict[str, str]): A dictionary mapping each key in the &#39;order&#39; list to a specific
                text snippet to be inserted into the pattern structure.
            comment (str): A comment or description associated with this blueprint.
        &#34;&#34;&#34;
        self.order = order
        self.pattern_structure = pattern_structure
        self.pattern_texts = pattern_texts
        self.comment = comment
        self._initialize_items()

    def _initialize_items(self):
        self.items: dict[str, RegexRequest] = {}
        for name, text in self.pattern_texts.items():
            pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                       f&#34;{text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
            regex_request = RegexRequest(
                p_type=&#34;Block&#34;,
                p_subtype=name,
                pattern=pattern,
                flags=self.pattern_structure[&#39;flags&#39;],
                comment=self.comment
            )
            self.items[name] = regex_request

    def to_list(self) -&gt; List[RegexRequest]:
        &#34;&#34;&#34;
        Generates a list of RegexRequest objects based on the blueprint.

        Returns:
            List[RegexRequest]: A list of generated RegexRequest objects following the blueprint&#39;s structure.
        &#34;&#34;&#34;
        return [self.items[name] for name in self.order]

    def validate_configuration(self) -&gt; None:
        &#34;&#34;&#34;
        Validates the blueprint&#39;s configuration to ensure consistency and correctness.

        Raises:
            ValueError: If any configuration inconsistency or error is found.
        &#34;&#34;&#34;
        # Check if all items in &#39;order&#39; exist in &#39;pattern_texts&#39;
        for name in self.order:
            if name not in self.pattern_texts:
                raise ValueError(
                    f&#34;Item &#39;{name}&#39; in &#39;order&#39; does not have a corresponding entry in &#39;pattern_texts&#39;.&#34;)

        # Ensure &#39;pattern_structure&#39; contains required keys
        required_keys = [&#39;beginning&#39;, &#39;ending&#39;, &#39;flags&#39;]
        for key in required_keys:
            if key not in self.pattern_structure:
                raise ValueError(
                    f&#34;&#39;pattern_structure&#39; is missing the required key: &#39;{key}&#39;.&#34;)

        # Validate &#39;flags&#39; in &#39;pattern_structure&#39;
        valid_flags = {&#34;IGNORECASE&#34;, &#34;MULTILINE&#34;,
                       &#34;DOTALL&#34;, &#34;UNICODE&#34;, &#34;VERBOSE&#34;}
        for flag in self.pattern_structure[&#39;flags&#39;]:
            if flag not in valid_flags:
                raise ValueError(
                    f&#34;Invalid flag &#39;{flag}&#39; in &#39;pattern_structure&#39;. Valid flags are: {&#39;, &#39;.join(valid_flags)}.&#34;)

        # Validate that &#39;beginning&#39; + &#39;ending&#39; patterns are valid regex patterns
        try:
            re.compile(
                self.pattern_structure[&#39;beginning&#39;] + self.pattern_structure[&#39;ending&#39;])
        except re.error as e:
            raise ValueError(
                f&#34;Invalid regex pattern in &#39;pattern_structure&#39;: {e}&#34;)

        # Confirm comment is a string
        if not isinstance(self.comment, str):
            raise ValueError(&#34;&#39;comment&#39; must be a string.&#34;)

    def add_item(self, name: str, pattern_text: str) -&gt; None:
        &#34;&#34;&#34;
        Adds a new pattern text to the blueprint and its corresponding key to the order.

        Args:
            name (str): The key name for the new pattern text.
            pattern_text (str): The specific text snippet to be inserted into the pattern structure for this new item.
        &#34;&#34;&#34;
        self.pattern_texts[name] = pattern_text
        pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                   f&#34;{pattern_text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
        regex_request = RegexRequest(
            p_type=&#34;Block&#34;,
            p_subtype=name,
            pattern=pattern,
            flags=self.pattern_structure[&#39;flags&#39;],
            comment=self.comment
        )
        self.items[name] = regex_request
        self.order.append(name)
        self.validate_configuration()

    def to_dict(self) -&gt; Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]:
        &#34;&#34;&#34;
        Converts the RegexBlueprint instance into a dictionary representation.

        Returns:
            Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]: A dictionary representation of the RegexBlueprint.
        &#34;&#34;&#34;
        return {
            &#34;order&#34;: self.order,
            &#34;pattern_structure&#34;: self.pattern_structure,
            &#34;pattern_texts&#34;: self.pattern_texts,
            &#34;comment&#34;: self.comment
        }

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of items defined in the blueprint&#39;s order.

        Returns:
            int: The length of the &#39;order&#39; list.
        &#34;&#34;&#34;
        return len(self.order)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Provides a detailed string representation of the RegexBlueprint instance for debugging.

        Returns:
            str: A string representation including the order, pattern structure, pattern texts, and comment.
        &#34;&#34;&#34;
        return f&#34;RegexBlueprint(Order: {self.order}, Pattern Structure: {self.pattern_structure}, Pattern Texts: {self.pattern_texts}, Comment: {self.comment})&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the RegexBlueprint instance, using the tree method to illustrate the structure.

        Returns:
            str: A tree-like string representation of the blueprint.
        &#34;&#34;&#34;
        return self.tree()

    def tree(self, depth: int = 0) -&gt; str:
        &#34;&#34;&#34;
        Generates a string representation of the blueprint hierarchy in a tree-like structure. This method is useful
        for visualizing the blueprint&#39;s pattern structure, pattern texts, and their hierarchical relationships.

        Args:
            depth (int): The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.

        Returns:
            str: A string representation of the regex blueprint in a tree-like structure, showing nested patterns indented according to their depth.
        &#34;&#34;&#34;
        result = &#34;  &#34; * depth + &#34;RegexBlueprint:\n&#34;
        for name in self.order:
            text = self.pattern_texts.get(name, &#39;&#39;)
            pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                       f&#34;{text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
            result += &#34;  &#34; * (depth + 1) + f&#34;{name}: Pattern: {pattern}\n&#34;
        return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.regex_settings.RegexBlueprint.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self, name: str, pattern_text: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new pattern text to the blueprint and its corresponding key to the order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The key name for the new pattern text.</dd>
<dt><strong><code>pattern_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The specific text snippet to be inserted into the pattern structure for this new item.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_item(self, name: str, pattern_text: str) -&gt; None:
    &#34;&#34;&#34;
    Adds a new pattern text to the blueprint and its corresponding key to the order.

    Args:
        name (str): The key name for the new pattern text.
        pattern_text (str): The specific text snippet to be inserted into the pattern structure for this new item.
    &#34;&#34;&#34;
    self.pattern_texts[name] = pattern_text
    pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
               f&#34;{pattern_text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
    regex_request = RegexRequest(
        p_type=&#34;Block&#34;,
        p_subtype=name,
        pattern=pattern,
        flags=self.pattern_structure[&#39;flags&#39;],
        comment=self.comment
    )
    self.items[name] = regex_request
    self.order.append(name)
    self.validate_configuration()</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexBlueprint.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the RegexBlueprint instance into a dictionary representation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]</code></dt>
<dd>A dictionary representation of the RegexBlueprint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]:
    &#34;&#34;&#34;
    Converts the RegexBlueprint instance into a dictionary representation.

    Returns:
        Dict[str, Union[List[str], Dict[str, Union[str, List[str]]], str]]: A dictionary representation of the RegexBlueprint.
    &#34;&#34;&#34;
    return {
        &#34;order&#34;: self.order,
        &#34;pattern_structure&#34;: self.pattern_structure,
        &#34;pattern_texts&#34;: self.pattern_texts,
        &#34;comment&#34;: self.comment
    }</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexBlueprint.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) ‑> List[<a title="orcaparse.regex_request.RegexRequest" href="regex_request.html#orcaparse.regex_request.RegexRequest">RegexRequest</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a list of RegexRequest objects based on the blueprint.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[RegexRequest]</code></dt>
<dd>A list of generated RegexRequest objects following the blueprint's structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; List[RegexRequest]:
    &#34;&#34;&#34;
    Generates a list of RegexRequest objects based on the blueprint.

    Returns:
        List[RegexRequest]: A list of generated RegexRequest objects following the blueprint&#39;s structure.
    &#34;&#34;&#34;
    return [self.items[name] for name in self.order]</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexBlueprint.tree"><code class="name flex">
<span>def <span class="ident">tree</span></span>(<span>self, depth: int = 0) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a string representation of the blueprint hierarchy in a tree-like structure. This method is useful
for visualizing the blueprint's pattern structure, pattern texts, and their hierarchical relationships.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code></dt>
<dd>The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the regex blueprint in a tree-like structure, showing nested patterns indented according to their depth.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree(self, depth: int = 0) -&gt; str:
    &#34;&#34;&#34;
    Generates a string representation of the blueprint hierarchy in a tree-like structure. This method is useful
    for visualizing the blueprint&#39;s pattern structure, pattern texts, and their hierarchical relationships.

    Args:
        depth (int): The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.

    Returns:
        str: A string representation of the regex blueprint in a tree-like structure, showing nested patterns indented according to their depth.
    &#34;&#34;&#34;
    result = &#34;  &#34; * depth + &#34;RegexBlueprint:\n&#34;
    for name in self.order:
        text = self.pattern_texts.get(name, &#39;&#39;)
        pattern = (f&#34;{self.pattern_structure[&#39;beginning&#39;]}&#34;
                   f&#34;{text}{self.pattern_structure[&#39;ending&#39;]}&#34;)
        result += &#34;  &#34; * (depth + 1) + f&#34;{name}: Pattern: {pattern}\n&#34;
    return result</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexBlueprint.validate_configuration"><code class="name flex">
<span>def <span class="ident">validate_configuration</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the blueprint's configuration to ensure consistency and correctness.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If any configuration inconsistency or error is found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_configuration(self) -&gt; None:
    &#34;&#34;&#34;
    Validates the blueprint&#39;s configuration to ensure consistency and correctness.

    Raises:
        ValueError: If any configuration inconsistency or error is found.
    &#34;&#34;&#34;
    # Check if all items in &#39;order&#39; exist in &#39;pattern_texts&#39;
    for name in self.order:
        if name not in self.pattern_texts:
            raise ValueError(
                f&#34;Item &#39;{name}&#39; in &#39;order&#39; does not have a corresponding entry in &#39;pattern_texts&#39;.&#34;)

    # Ensure &#39;pattern_structure&#39; contains required keys
    required_keys = [&#39;beginning&#39;, &#39;ending&#39;, &#39;flags&#39;]
    for key in required_keys:
        if key not in self.pattern_structure:
            raise ValueError(
                f&#34;&#39;pattern_structure&#39; is missing the required key: &#39;{key}&#39;.&#34;)

    # Validate &#39;flags&#39; in &#39;pattern_structure&#39;
    valid_flags = {&#34;IGNORECASE&#34;, &#34;MULTILINE&#34;,
                   &#34;DOTALL&#34;, &#34;UNICODE&#34;, &#34;VERBOSE&#34;}
    for flag in self.pattern_structure[&#39;flags&#39;]:
        if flag not in valid_flags:
            raise ValueError(
                f&#34;Invalid flag &#39;{flag}&#39; in &#39;pattern_structure&#39;. Valid flags are: {&#39;, &#39;.join(valid_flags)}.&#34;)

    # Validate that &#39;beginning&#39; + &#39;ending&#39; patterns are valid regex patterns
    try:
        re.compile(
            self.pattern_structure[&#39;beginning&#39;] + self.pattern_structure[&#39;ending&#39;])
    except re.error as e:
        raise ValueError(
            f&#34;Invalid regex pattern in &#39;pattern_structure&#39;: {e}&#34;)

    # Confirm comment is a string
    if not isinstance(self.comment, str):
        raise ValueError(&#34;&#39;comment&#39; must be a string.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings"><code class="flex name class">
<span>class <span class="ident">RegexSettings</span></span>
<span>(</span><span>settings_file: str | None = None, items: Optional[Dict[str, Union[<a title="orcaparse.regex_request.RegexRequest" href="regex_request.html#orcaparse.regex_request.RegexRequest">RegexRequest</a>, ForwardRef('<a title="orcaparse.regex_settings.RegexSettings" href="#orcaparse.regex_settings.RegexSettings">RegexSettings</a>')]]] = None, order: Optional[List[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a RegexSettings instance, which can either load settings from a file or be instantiated with provided items and order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>settings_file</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The path to a JSON file containing regex settings. If not provided, an empty or pre-defined configuration is used.</dd>
<dt>items (Optional[Dict[str, Union[RegexRequest, 'RegexSettings']]]): A dictionary of items (RegexRequest objects or nested RegexSettings) keyed by their names.</dt>
<dt><strong><code>order</code></strong> :&ensp;<code>Optional[List[str]]</code></dt>
<dd>A list of item names specifying the order in which they should be processed.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If only one of items or order is provided, but not both.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexSettings:
    def __init__(self, settings_file: Optional[str] = None, items: Optional[Dict[str, Union[RegexRequest, &#39;RegexSettings&#39;]]] = None, order: Optional[List[str]] = None) -&gt; None:
        &#34;&#34;&#34;
        Initializes a RegexSettings instance, which can either load settings from a file or be instantiated with provided items and order.

        Args:
            settings_file (Optional[str]): The path to a JSON file containing regex settings. If not provided, an empty or pre-defined configuration is used.
            items (Optional[Dict[str, Union[RegexRequest, &#39;RegexSettings&#39;]]]): A dictionary of items (RegexRequest objects or nested RegexSettings) keyed by their names.
            order (Optional[List[str]]): A list of item names specifying the order in which they should be processed.

        Raises:
            ValueError: If only one of items or order is provided, but not both.
        &#34;&#34;&#34;
        if items is None and order is None:
            if settings_file is not None:
                # Load from file
                self.items = {}
                self.order = []
                self.load_settings(settings_file)
            else:
                # Empty class
                self.items = {}
                self.order = []
        elif items is not None and order is not None:
            self.items = items
            self.order = order
        else:
            raise ValueError(
                &#34;Both &#39;items&#39; and &#39;order&#39; must be provided, or neither.&#34;)

        self.validate_configuration()

    def add_item(self, name: str, item: Union[RegexRequest, &#39;RegexSettings&#39;], rewrite: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Adds an item (RegexRequest or nested RegexSettings) to the settings.

        Args:
            name (str): The name/key associated with the item.
            item (Union[RegexRequest, &#39;RegexSettings&#39;]): The item to add, which can be a RegexRequest or another RegexSettings instance.
            rewrite (bool): Whether to overwrite an existing item with the same name. Defaults to False.

        Raises:
            ValueError: If the name already exists in the items.
        &#34;&#34;&#34;
        if name in self.items and not rewrite:
            raise ValueError(f&#34;Item with name &#39;{name}&#39; already exists.&#34;)
        self.items[name] = item
        if name not in self.order:
            self.order.append(name)
        self.validate_configuration()

    def set_order(self, order: List[str]) -&gt; None:
        &#34;&#34;&#34;
        Sets the order of items.

        Args:
            order (List[str]): A list of item names specifying the order.

        Raises:
            ValueError: If any name in the order list does not exist in the items.
        &#34;&#34;&#34;
        for name in order:
            if name not in self.items:
                raise ValueError(
                    f&#34;Item with name &#39;{name}&#39; does not exist in items.&#34;)
        self.order = order
        self.validate_configuration()

    def get_ordered_items(self) -&gt; List[Union[RegexRequest, &#39;RegexSettings&#39;]]:
        &#34;&#34;&#34;
        Returns a list of items in the specified order.

        Returns:
            List[Union[RegexRequest, &#39;RegexSettings&#39;]]: A list of ordered items.

        Raises:
            ValueError: If any name in the order list does not exist in the items.
        &#34;&#34;&#34;
        ordered_items = [self.items[name]
                         for name in self.order if name in self.items]
        if len(ordered_items) != len(self.order):
            missing_items = set(self.order) - set(self.items.keys())
            raise ValueError(
                f&#34;Missing items in &#39;items&#39;: {&#39;, &#39;.join(missing_items)}&#34;)
        return ordered_items

    def to_list(self) -&gt; List[Union[RegexRequest, &#39;RegexSettings&#39;]]:
        &#34;&#34;&#34;
        Flattens the items to a list, expanding nested RegexSettings into their constituent RegexRequest objects.

        Returns:
            List[Union[RegexRequest, &#39;RegexSettings&#39;]]: A flattened list of RegexRequest objects and/or RegexSettings instances.
        &#34;&#34;&#34;
        ordered_items = []
        for name in self.order:
            item = self.items[name]
            if isinstance(item, RegexRequest):
                ordered_items.append(item)
            elif isinstance(item, (RegexSettings, RegexBlueprint)):
                ordered_items.extend(item.to_list())
            else:
                raise TypeError(f&#34;Unknown type of item &#39;{name}&#39;: {type(item)}&#34;)
        return ordered_items

    def load_settings(self, settings_file: str) -&gt; None:
        &#34;&#34;&#34;
        Loads settings from a JSON file and populates the RegexSettings instance based on the file&#39;s content.

        Args:
            settings_file (str): The path to the JSON file containing the settings.
        &#34;&#34;&#34;
        with open(settings_file, &#34;r&#34;) as file:
            settings = json.load(file)
            self.parse_settings(settings)

    def parse_settings(self, settings: Dict[str, Union[Dict, List[str]]]) -&gt; None:
        &#34;&#34;&#34;
        Parses the given settings to populate this RegexSettings instance with
        RegexRequest objects, RegexBlueprint objects, or nested RegexSettings objects based on the settings structure.

        :param settings: The settings to parse, typically loaded from a JSON file.
        &#34;&#34;&#34;
        self.items: Dict[str, Union[RegexRequest,
                                    RegexBlueprint, &#39;RegexSettings&#39;]] = {}
        self.order = settings.get(&#39;order&#39;, [])

        for name in self.order:
            item_settings = settings[name]

            # Handling a direct RegexRequest (defined by a &#39;pattern&#39; key)
            if &#39;pattern&#39; in item_settings:
                request = RegexRequest(
                    p_type=item_settings[&#39;p_type&#39;],
                    p_subtype=item_settings[&#39;p_subtype&#39;],
                    pattern=item_settings[&#39;pattern&#39;],
                    flags=item_settings.get(&#39;flags&#39;, []),
                    comment=item_settings.get(&#39;comment&#39;, &#39;&#39;)
                )
                self.items[name] = request

            # Handling a RegexBlueprint (defined by a &#39;pattern_structure&#39; key)
            elif &#39;pattern_structure&#39; in item_settings:
                blueprint = RegexBlueprint(
                    order=item_settings[&#39;order&#39;],
                    pattern_structure=item_settings[&#39;pattern_structure&#39;],
                    pattern_texts=item_settings[&#39;pattern_texts&#39;],
                    comment=item_settings.get(&#39;comment&#39;, &#39;&#39;)
                )
                self.items[name] = blueprint

            # Handling nested RegexSettings
            else:
                # If the item is a nested structure but not a direct RegexRequest or Blueprint
                subgroup = RegexSettings()
                subgroup.parse_settings(item_settings)
                self.items[name] = subgroup

        # Validate the configuration after parsing
        self.validate_configuration()

    def tree(self, depth: int = 0) -&gt; str:
        &#34;&#34;&#34;
        Generates a string representation of the settings hierarchy in a tree-like structure.
        This method is useful for visualizing the nested structure of regex settings and blueprints.

        Args:
            depth (int): The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.

        Returns:
            str: A string representation of the regex settings in a tree-like structure, showing nested items indented according to their depth.
        &#34;&#34;&#34;
        result = &#34;  &#34; * depth + &#34;RegexGroup:\n&#34;
        for name in self.order:
            item = self.items[name]
            # If the item is a RegexSettings or RegexBlueprint, recursively call the tree method to represent its nested structure
            if isinstance(item, (RegexSettings, RegexBlueprint)):
                result += &#34;  &#34; * (depth + 1) + \
                    f&#34;{name}:\n&#34; + item.tree(depth + 2)
            # If the item is a RegexRequest, simply append its string representation
            else:
                result += &#34;  &#34; * (depth + 1) + f&#34;{name}: {item}\n&#34;
        return result

    def validate_configuration(self) -&gt; None:
        &#34;&#34;&#34;
        Validates the regex configuration to ensure consistency between &#39;order&#39; and &#39;items&#39;.
        Also recursively validates the configuration of nested RegexSettings instances.

        Raises:
            ValueError: If an item in &#39;order&#39; does not have a corresponding entry in &#39;items&#39;.

        Warns:
            RuntimeWarning: If there are keys in &#39;items&#39; not listed in &#39;order&#39;.
        &#34;&#34;&#34;
        # Check for items in &#39;order&#39; that are not in &#39;items&#39;
        for name in self.order:
            if name not in self.items:
                raise ValueError(
                    f&#34;Error: Item &#39;{name}&#39; listed in &#39;order&#39; but not found in &#39;items&#39;.&#34;)

        for name, item in self.items.items():
            item.validate_configuration()
            if name not in self.order:
                warnings.warn(
                    f&#34;Warning: Item &#39;{name}&#39; found in &#39;items&#39; but not listed in &#39;order&#39;.&#34;, RuntimeWarning)

    def to_dict(self) -&gt; Dict[str, Union[Dict, List[str]]]:
        &#34;&#34;&#34;Converts the RegexSettings instance and its nested structure to a dictionary.&#34;&#34;&#34;
        result = {&#34;order&#34;: self.order}
        for name in self.order:
            item = self.items[name]
            result[name] = item.to_dict() if isinstance(
                item, (RegexRequest, RegexSettings, RegexBlueprint)) else item
        return result

    def save_as_json(self, filename: str) -&gt; None:
        &#34;&#34;&#34;Saves the RegexSettings instance as a JSON file.&#34;&#34;&#34;
        with open(filename, &#39;w&#39;) as file:
            json.dump(self.to_dict(), file, indent=4)

    def __repr__(self) -&gt; str:
        return f&#34;RegexGroup(Order: {self.order}, Items: {list(self.items.keys())})&#34;

    def __len__(self) -&gt; str:
        return sum(len(item) for item in self.items.values())

    def __str__(self) -&gt; str:
        return self.tree()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.regex_settings.RegexSettings.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self, name: str, item: Union[<a title="orcaparse.regex_request.RegexRequest" href="regex_request.html#orcaparse.regex_request.RegexRequest">RegexRequest</a>, ForwardRef('<a title="orcaparse.regex_settings.RegexSettings" href="#orcaparse.regex_settings.RegexSettings">RegexSettings</a>')], rewrite: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an item (RegexRequest or nested RegexSettings) to the settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name/key associated with the item.</dd>
<dt>item (Union[RegexRequest, 'RegexSettings']): The item to add, which can be a RegexRequest or another RegexSettings instance.</dt>
<dt><strong><code>rewrite</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to overwrite an existing item with the same name. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the name already exists in the items.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_item(self, name: str, item: Union[RegexRequest, &#39;RegexSettings&#39;], rewrite: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Adds an item (RegexRequest or nested RegexSettings) to the settings.

    Args:
        name (str): The name/key associated with the item.
        item (Union[RegexRequest, &#39;RegexSettings&#39;]): The item to add, which can be a RegexRequest or another RegexSettings instance.
        rewrite (bool): Whether to overwrite an existing item with the same name. Defaults to False.

    Raises:
        ValueError: If the name already exists in the items.
    &#34;&#34;&#34;
    if name in self.items and not rewrite:
        raise ValueError(f&#34;Item with name &#39;{name}&#39; already exists.&#34;)
    self.items[name] = item
    if name not in self.order:
        self.order.append(name)
    self.validate_configuration()</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.get_ordered_items"><code class="name flex">
<span>def <span class="ident">get_ordered_items</span></span>(<span>self) ‑> List[Union[<a title="orcaparse.regex_request.RegexRequest" href="regex_request.html#orcaparse.regex_request.RegexRequest">RegexRequest</a>, <a title="orcaparse.regex_settings.RegexSettings" href="#orcaparse.regex_settings.RegexSettings">RegexSettings</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of items in the specified order.</p>
<h2 id="returns">Returns</h2>
<p>List[Union[RegexRequest, 'RegexSettings']]: A list of ordered items.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If any name in the order list does not exist in the items.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ordered_items(self) -&gt; List[Union[RegexRequest, &#39;RegexSettings&#39;]]:
    &#34;&#34;&#34;
    Returns a list of items in the specified order.

    Returns:
        List[Union[RegexRequest, &#39;RegexSettings&#39;]]: A list of ordered items.

    Raises:
        ValueError: If any name in the order list does not exist in the items.
    &#34;&#34;&#34;
    ordered_items = [self.items[name]
                     for name in self.order if name in self.items]
    if len(ordered_items) != len(self.order):
        missing_items = set(self.order) - set(self.items.keys())
        raise ValueError(
            f&#34;Missing items in &#39;items&#39;: {&#39;, &#39;.join(missing_items)}&#34;)
    return ordered_items</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.load_settings"><code class="name flex">
<span>def <span class="ident">load_settings</span></span>(<span>self, settings_file: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Loads settings from a JSON file and populates the RegexSettings instance based on the file's content.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>settings_file</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the JSON file containing the settings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_settings(self, settings_file: str) -&gt; None:
    &#34;&#34;&#34;
    Loads settings from a JSON file and populates the RegexSettings instance based on the file&#39;s content.

    Args:
        settings_file (str): The path to the JSON file containing the settings.
    &#34;&#34;&#34;
    with open(settings_file, &#34;r&#34;) as file:
        settings = json.load(file)
        self.parse_settings(settings)</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.parse_settings"><code class="name flex">
<span>def <span class="ident">parse_settings</span></span>(<span>self, settings: Dict[str, Union[Dict, List[str]]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the given settings to populate this RegexSettings instance with
RegexRequest objects, RegexBlueprint objects, or nested RegexSettings objects based on the settings structure.</p>
<p>:param settings: The settings to parse, typically loaded from a JSON file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_settings(self, settings: Dict[str, Union[Dict, List[str]]]) -&gt; None:
    &#34;&#34;&#34;
    Parses the given settings to populate this RegexSettings instance with
    RegexRequest objects, RegexBlueprint objects, or nested RegexSettings objects based on the settings structure.

    :param settings: The settings to parse, typically loaded from a JSON file.
    &#34;&#34;&#34;
    self.items: Dict[str, Union[RegexRequest,
                                RegexBlueprint, &#39;RegexSettings&#39;]] = {}
    self.order = settings.get(&#39;order&#39;, [])

    for name in self.order:
        item_settings = settings[name]

        # Handling a direct RegexRequest (defined by a &#39;pattern&#39; key)
        if &#39;pattern&#39; in item_settings:
            request = RegexRequest(
                p_type=item_settings[&#39;p_type&#39;],
                p_subtype=item_settings[&#39;p_subtype&#39;],
                pattern=item_settings[&#39;pattern&#39;],
                flags=item_settings.get(&#39;flags&#39;, []),
                comment=item_settings.get(&#39;comment&#39;, &#39;&#39;)
            )
            self.items[name] = request

        # Handling a RegexBlueprint (defined by a &#39;pattern_structure&#39; key)
        elif &#39;pattern_structure&#39; in item_settings:
            blueprint = RegexBlueprint(
                order=item_settings[&#39;order&#39;],
                pattern_structure=item_settings[&#39;pattern_structure&#39;],
                pattern_texts=item_settings[&#39;pattern_texts&#39;],
                comment=item_settings.get(&#39;comment&#39;, &#39;&#39;)
            )
            self.items[name] = blueprint

        # Handling nested RegexSettings
        else:
            # If the item is a nested structure but not a direct RegexRequest or Blueprint
            subgroup = RegexSettings()
            subgroup.parse_settings(item_settings)
            self.items[name] = subgroup

    # Validate the configuration after parsing
    self.validate_configuration()</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.save_as_json"><code class="name flex">
<span>def <span class="ident">save_as_json</span></span>(<span>self, filename: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the RegexSettings instance as a JSON file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_json(self, filename: str) -&gt; None:
    &#34;&#34;&#34;Saves the RegexSettings instance as a JSON file.&#34;&#34;&#34;
    with open(filename, &#39;w&#39;) as file:
        json.dump(self.to_dict(), file, indent=4)</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.set_order"><code class="name flex">
<span>def <span class="ident">set_order</span></span>(<span>self, order: List[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the order of items.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A list of item names specifying the order.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If any name in the order list does not exist in the items.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_order(self, order: List[str]) -&gt; None:
    &#34;&#34;&#34;
    Sets the order of items.

    Args:
        order (List[str]): A list of item names specifying the order.

    Raises:
        ValueError: If any name in the order list does not exist in the items.
    &#34;&#34;&#34;
    for name in order:
        if name not in self.items:
            raise ValueError(
                f&#34;Item with name &#39;{name}&#39; does not exist in items.&#34;)
    self.order = order
    self.validate_configuration()</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> Dict[str, Union[Dict, List[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the RegexSettings instance and its nested structure to a dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; Dict[str, Union[Dict, List[str]]]:
    &#34;&#34;&#34;Converts the RegexSettings instance and its nested structure to a dictionary.&#34;&#34;&#34;
    result = {&#34;order&#34;: self.order}
    for name in self.order:
        item = self.items[name]
        result[name] = item.to_dict() if isinstance(
            item, (RegexRequest, RegexSettings, RegexBlueprint)) else item
    return result</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.to_list"><code class="name flex">
<span>def <span class="ident">to_list</span></span>(<span>self) ‑> List[Union[<a title="orcaparse.regex_request.RegexRequest" href="regex_request.html#orcaparse.regex_request.RegexRequest">RegexRequest</a>, <a title="orcaparse.regex_settings.RegexSettings" href="#orcaparse.regex_settings.RegexSettings">RegexSettings</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Flattens the items to a list, expanding nested RegexSettings into their constituent RegexRequest objects.</p>
<h2 id="returns">Returns</h2>
<p>List[Union[RegexRequest, 'RegexSettings']]: A flattened list of RegexRequest objects and/or RegexSettings instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_list(self) -&gt; List[Union[RegexRequest, &#39;RegexSettings&#39;]]:
    &#34;&#34;&#34;
    Flattens the items to a list, expanding nested RegexSettings into their constituent RegexRequest objects.

    Returns:
        List[Union[RegexRequest, &#39;RegexSettings&#39;]]: A flattened list of RegexRequest objects and/or RegexSettings instances.
    &#34;&#34;&#34;
    ordered_items = []
    for name in self.order:
        item = self.items[name]
        if isinstance(item, RegexRequest):
            ordered_items.append(item)
        elif isinstance(item, (RegexSettings, RegexBlueprint)):
            ordered_items.extend(item.to_list())
        else:
            raise TypeError(f&#34;Unknown type of item &#39;{name}&#39;: {type(item)}&#34;)
    return ordered_items</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.tree"><code class="name flex">
<span>def <span class="ident">tree</span></span>(<span>self, depth: int = 0) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a string representation of the settings hierarchy in a tree-like structure.
This method is useful for visualizing the nested structure of regex settings and blueprints.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>depth</code></strong> :&ensp;<code>int</code></dt>
<dd>The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the regex settings in a tree-like structure, showing nested items indented according to their depth.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree(self, depth: int = 0) -&gt; str:
    &#34;&#34;&#34;
    Generates a string representation of the settings hierarchy in a tree-like structure.
    This method is useful for visualizing the nested structure of regex settings and blueprints.

    Args:
        depth (int): The current depth in the tree, used for indentation to represent hierarchy levels. Defaults to 0 at the root level.

    Returns:
        str: A string representation of the regex settings in a tree-like structure, showing nested items indented according to their depth.
    &#34;&#34;&#34;
    result = &#34;  &#34; * depth + &#34;RegexGroup:\n&#34;
    for name in self.order:
        item = self.items[name]
        # If the item is a RegexSettings or RegexBlueprint, recursively call the tree method to represent its nested structure
        if isinstance(item, (RegexSettings, RegexBlueprint)):
            result += &#34;  &#34; * (depth + 1) + \
                f&#34;{name}:\n&#34; + item.tree(depth + 2)
        # If the item is a RegexRequest, simply append its string representation
        else:
            result += &#34;  &#34; * (depth + 1) + f&#34;{name}: {item}\n&#34;
    return result</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_settings.RegexSettings.validate_configuration"><code class="name flex">
<span>def <span class="ident">validate_configuration</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the regex configuration to ensure consistency between 'order' and 'items'.
Also recursively validates the configuration of nested RegexSettings instances.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an item in 'order' does not have a corresponding entry in 'items'.</dd>
</dl>
<h2 id="warns">Warns</h2>
<dl>
<dt><code>RuntimeWarning</code></dt>
<dd>If there are keys in 'items' not listed in 'order'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_configuration(self) -&gt; None:
    &#34;&#34;&#34;
    Validates the regex configuration to ensure consistency between &#39;order&#39; and &#39;items&#39;.
    Also recursively validates the configuration of nested RegexSettings instances.

    Raises:
        ValueError: If an item in &#39;order&#39; does not have a corresponding entry in &#39;items&#39;.

    Warns:
        RuntimeWarning: If there are keys in &#39;items&#39; not listed in &#39;order&#39;.
    &#34;&#34;&#34;
    # Check for items in &#39;order&#39; that are not in &#39;items&#39;
    for name in self.order:
        if name not in self.items:
            raise ValueError(
                f&#34;Error: Item &#39;{name}&#39; listed in &#39;order&#39; but not found in &#39;items&#39;.&#34;)

    for name, item in self.items.items():
        item.validate_configuration()
        if name not in self.order:
            warnings.warn(
                f&#34;Warning: Item &#39;{name}&#39; found in &#39;items&#39; but not listed in &#39;order&#39;.&#34;, RuntimeWarning)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orcaparse" href="index.html">orcaparse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orcaparse.regex_settings.RegexBlueprint" href="#orcaparse.regex_settings.RegexBlueprint">RegexBlueprint</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.regex_settings.RegexBlueprint.add_item" href="#orcaparse.regex_settings.RegexBlueprint.add_item">add_item</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexBlueprint.to_dict" href="#orcaparse.regex_settings.RegexBlueprint.to_dict">to_dict</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexBlueprint.to_list" href="#orcaparse.regex_settings.RegexBlueprint.to_list">to_list</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexBlueprint.tree" href="#orcaparse.regex_settings.RegexBlueprint.tree">tree</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexBlueprint.validate_configuration" href="#orcaparse.regex_settings.RegexBlueprint.validate_configuration">validate_configuration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.regex_settings.RegexSettings" href="#orcaparse.regex_settings.RegexSettings">RegexSettings</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.regex_settings.RegexSettings.add_item" href="#orcaparse.regex_settings.RegexSettings.add_item">add_item</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.get_ordered_items" href="#orcaparse.regex_settings.RegexSettings.get_ordered_items">get_ordered_items</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.load_settings" href="#orcaparse.regex_settings.RegexSettings.load_settings">load_settings</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.parse_settings" href="#orcaparse.regex_settings.RegexSettings.parse_settings">parse_settings</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.save_as_json" href="#orcaparse.regex_settings.RegexSettings.save_as_json">save_as_json</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.set_order" href="#orcaparse.regex_settings.RegexSettings.set_order">set_order</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.to_dict" href="#orcaparse.regex_settings.RegexSettings.to_dict">to_dict</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.to_list" href="#orcaparse.regex_settings.RegexSettings.to_list">to_list</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.tree" href="#orcaparse.regex_settings.RegexSettings.tree">tree</a></code></li>
<li><code><a title="orcaparse.regex_settings.RegexSettings.validate_configuration" href="#orcaparse.regex_settings.RegexSettings.validate_configuration">validate_configuration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>