<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orcaparse.orca_elements API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orcaparse.orca_elements</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import warnings
from datetime import timedelta

import numpy as np
import pandas as pd

from .data import Data
from .elements import AvailableBlocksGeneral, Block, Element, ExtractionError
from .units_and_constants import ureg


class AvailableBlocksOrca(AvailableBlocksGeneral):
    blocks: dict[str, type[Element]] = {}


@AvailableBlocksOrca.register_block
class BlockOrcaWithStandardHeader(Block):
    &#34;&#34;&#34;
    A specialized type of Block that expects a standard header format.

    This class extends `Block` to handle cases where blocks of data include a standardized header section, marked by specific delimiter patterns. It provides a customized implementation of the `extract_name_header_and_body` method to parse such headers and separate the block into readable name, header, and body components.

    The standard header format is expected to be delimited by lines of repeating special characters (e.g., &#39;-&#39;, &#39;*&#39;, &#39;#&#39;) and may contain multiple lines of text that are considered part of the header.
    &#34;&#34;&#34;

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        &#34;&#34;&#34;
        Extract the block&#39;s name, header, and body based on a standard header format.

        This method uses regular expressions to identify and separate the header section from the body. It then processes the header to extract a readable name and the header content itself. The remaining text is considered the body of the block.

        Returns:
            tuple[str, str | None, str]: A tuple containing the block&#39;s name, header (or None if not applicable), and body.

        Raises:
            Warning: If no recognizable header is found, indicating an unexpected format.
        &#34;&#34;&#34;
        # Define regex pattern to split header and body
        pattern = r&#34;^(([ \t]*[-*#]{7,}[ \t]*\n)(.*?)(\n[ \t]*[-*#]{7,}[ \t]*\n|$))&#34;

        # Search for the pattern in self.raw_data using re.DOTALL to make &#39;.&#39; match newlines
        match = re.search(pattern, self.raw_data, re.DOTALL)

        if match:
            # Header is the content between the first and second header delimiters

            # Body is the content after the second header delimiter
            # The end of the header delimiter is marked by the start of the body_raw
            body_start = match.end(1)
            header_raw = self.raw_data[:body_start]
            body_raw = self.raw_data[body_start:]

            readable_lines = []

            # Split the header into lines
            lines = header_raw.split(&#39;\n&#39;)

            # Iterate over lines to find readable content
            for line in lines:
                # Check if the line is not solely composed of whitespace or special symbols
                if not re.match(r&#34;^[ \t]*[-*#=]*[ \t]*$&#34;, line):
                    # Extract the central text if the line is surrounded by a maximum of one special symbol on each side
                    central_text_match = re.match(
                        r&#34;^[ \t]*[-*#=]{,1}[ \t]*(.*?)[ \t]*[-*#=]{,1}[ \t]*$&#34;, line)
                    if central_text_match:
                        # Check that something was found and collect the first group result
                        central_text = central_text_match.group(1).strip()
                        if central_text:  # Ensure central_text is not empty
                            readable_lines.append(central_text)

            # Combine readable lines into a single string
            readable_name = &#39; &#39;.join(readable_lines).strip()

            if len(readable_name) &lt; 2:
                warnings.warn(
                    f&#39;No readable name found in the header: {header_raw}&#39;)
                readable_name = Element.process_invalid_name(self.raw_data)

            return readable_name, header_raw, body_raw
        else:
            warnings.warn(
                f&#39;No header found in\n{self.raw_data}\n, and that is really weird as it was extracted based on the idea that there is a header in it&#39;)
            # If no match is found, put everything into header
            return Element.process_invalid_name(self.raw_data), None, self.raw_data


@AvailableBlocksOrca.register_block
class BlockOrcaUnrecognizedWithHeader(BlockOrcaWithStandardHeader):
    pass


@AvailableBlocksOrca.register_block
class BlockOrcaUnrecognizedNotification(Block):
    pass


@AvailableBlocksOrca.register_block
class BlockOrcaUnrecognizedMessage(Block):
    pass


@AvailableBlocksOrca.register_block
class BlockOrcaIcon(Block):
    data_available: bool = True

    def readable_name(self) -&gt; str:
        return &#39;Icon&#39;

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;Orca Icon&#39;, None, self.raw_data

    def data(self) -&gt; Data:
        &#39;&#39;&#39;
        Icon is icon, noting to extract except for the ascii symbols
        &#39;&#39;&#39;
        return Data(data={&#39;Icon&#39;: self.raw_data}, comment=&#34;Raw `Icon` string&#34;)

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;Orca Icon&#39;, None, self.raw_data


@AvailableBlocksOrca.register_block
class BlockOrcaAllRightsReserved(Block):
    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;All Rights Reserved&#39;, None, self.raw_data


@AvailableBlocksOrca.register_block
class BlockOrcaFinalSinglePointEnergy(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;FINAL SINGLE POINT ENERGY&#39;, None, self.raw_data

    def data(self) -&gt; Data:
        &#39;&#39;&#39;
        returns FINAL SINGLE POINT ENERGY in Eh
        &#39;&#39;&#39;
        pattern = r&#34;FINAL SINGLE POINT ENERGY\s+(-?\d+\.\d+)&#34;

        # Search for the pattern in the text
        match = re.search(pattern, self.raw_data)

        if not match:
            raise ExtractionError(&#34;No energy match found in the data.&#34;)

        # Extract the floating-point number from the first capturing group
        energy = match.group(1)

        try:
            energy = float(energy) * ureg.Eh
            return Data(data={&#39;Energy&#39;: energy}, comment=&#39;`Energy` in pint format, to extract the value in Eh, use property .magnitude&#39;)
        except ValueError:
            raise ExtractionError(
                f&#34;Failed to convert the extracted energy {energy} to a floating-point number.&#34;)
        except Exception as e:
            # For any other unexpected exceptions, raise the original exception
            # You might want to log this exception or handle it differently depending on your application&#39;s needs
            raise e


@AvailableBlocksOrca.register_block
class BlockOrcaScfConverged(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;SCF convergence message&#39;, None, self.raw_data

    def data(self) -&gt; Data:
        # Check for the presence of &#34;SUCCESS&#34;
        success_match = re.search(r&#34;SUCCESS&#34;, self.raw_data)

        # Define regex pattern to match the number of cycles
        cycles_pattern = r&#34;(\d+)\s+CYCLES&#34;

        # Search for the cycles pattern in self.raw_data
        cycles_match = re.search(cycles_pattern, self.raw_data)

        # Prepare the result dictionary
        result = {
            # True if &#34;SUCCESS&#34; is found, False otherwise
            &#39;Success&#39;: bool(success_match),
            &#39;Cycles&#39;: None  # Default value for Cycles
        }

        # If a match for cycles is found, extract and update the number of cycles in the result dictionary
        if cycles_match:
            result[&#39;Cycles&#39;] = int(cycles_match.group(1))

        return Data(data=result, comment=&#39;bool for `Success` of the extraction and int for amount of `Cycles`&#39;)


@AvailableBlocksOrca.register_block
class BlockOrcaDipoleMoment(BlockOrcaWithStandardHeader):
    data_available: bool = True

    def data(self) -&gt; dict:
        # Initialize the result dictionary
        result = {}

        # Define regex pattern for lines with &#34;text: 3 numbers&#34;
        pattern_three_numbers = r&#34;([a-zA-Z \(\).]+):\s*(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)[ \t]*\n&#34;
        # Define regex pattern for lines with &#34;text: 1 number&#34;
        pattern_one_number = r&#34;([a-zA-Z \(\).]+):\s*(-?\d+\.\d+)[ \t]*(?:\n|\Z)&#34;

        # Find all matches for the three-number pattern
        matches_three_numbers = re.findall(
            pattern_three_numbers, self.raw_data)
        for match in matches_three_numbers:
            label, x, y, z = match
            result[label.strip()] = np.array([float(x), float(y), float(z)])

        # Find all matches for the one-number pattern
        matches_one_number = re.findall(pattern_one_number, self.raw_data)
        for match in matches_one_number:
            label, value = match
            if &#34;(Debye)&#34; in label:
                unit = &#34;Debye&#34;
            else:
                unit = &#34;a.u.&#34;
            result[label.strip()] = float(
                value)*ureg.debye if unit == &#34;Debye&#34; else float(value)

        return Data(data=result, comment=&#39;Numpy arrays of contributions, total dipole moment and pint object of `Magnitude (Debye)`.\nThe magnitude of the magnitude in Debye can be extracted from pint with .magnitude property.&#39;)


@AvailableBlocksOrca.register_block
class BlockOrcaOrbitalEnergies(BlockOrcaWithStandardHeader):
    data_available: bool = True

    def data(self) -&gt; dict[str, pd.DataFrame]:
        # Define regex pattern for extracting orbital data lines
        pattern_orbital_data = r&#34;\s*(\d+)\s+([0-1]\.\d{4})\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)\s*&#34;

        # Split the raw data into lines
        lines = self.raw_data.split(&#39;\n&#39;)

        # Initialize containers for spin up and spin down data
        spin_up_data = []
        spin_down_data = []

        # Flag to switch between spin up and spin down data collection
        collecting_spin_down = False

        # Iterate over lines to fill spin_up_data and spin_down_data
        for line in lines:
            if &#34;SPIN UP ORBITALS&#34; in line:
                collecting_spin_down = False
                continue
            elif &#34;SPIN DOWN ORBITALS&#34; in line:
                collecting_spin_down = True
                continue

            match = re.match(pattern_orbital_data, line)
            if match:
                # Extract orbital data
                no, occ, e_eh, e_ev = match.groups()
                data_row = [int(no), float(occ), float(
                    e_eh) * ureg.Eh, float(e_ev) * ureg.eV]

                # Append to the correct list based on the current section
                if collecting_spin_down:
                    spin_down_data.append(data_row)
                else:
                    spin_up_data.append(data_row)

        # Convert lists to pandas DataFrames
        columns = [&#39;NO&#39;, &#39;OCC&#39;, &#39;E(Eh)&#39;, &#39;E(eV)&#39;]
        spin_up_df = pd.DataFrame(spin_up_data, columns=columns)
        spin_down_df = pd.DataFrame(spin_down_data, columns=columns)

        # Return a dictionary containing both DataFrames
        return Data(data={&#39;Spin Up&#39;: spin_up_df, &#39;Spin Down&#39;: spin_down_df}, comment=&#39;Pandas DataFrames `Spin Up` and `Spin Down`. Energy is represented by pint object. Magnitude cane be extracted with .magnitude property.&#39;)


@AvailableBlocksOrca.register_block
class BlockOrcaTerminatedNormally(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;ORCA TERMINATED NORMALLY&#39;, None, self.raw_data

    def data(self) -&gt; bool:
        &#39;&#39;&#39;
        returns True meaning that the block exists
        &#39;&#39;&#39;
        return Data(data={&#39;Termination status&#39;: True}, comment=&#39;`Termination status` is always `True`, otherwise you wound`t find this block.&#39;)


@AvailableBlocksOrca.register_block
class BlockOrcaTotalRunTime(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;TOTAL RUN TIME&#39;, None, self.raw_data

    def data(self):
        # Define the regex pattern to match the total run time
        pattern = r&#34;TOTAL RUN TIME:\s*(\d+)\s*days\s*(\d+)\s*hours\s*(\d+)\s*minutes\s*(\d+)\s*seconds\s*(\d+)\s*msec&#34;

        # Search for the pattern in self.raw_data
        match = re.search(pattern, self.raw_data)

        # Check if a match is found
        if match:
            # Extract the components of the total run time
            days, hours, minutes, seconds, msec = match.groups()

            # Convert the extracted values to integers and milliseconds to seconds
            days = int(days)
            hours = int(hours)
            minutes = int(minutes)
            # Convert milliseconds to seconds
            seconds = int(seconds) + int(msec) / 1000.0

            # Create a timedelta object representing the total run time
            run_time = timedelta(days=days, hours=hours,
                                 minutes=minutes, seconds=seconds)

            return Data(data={&#39;Run Time&#39;: run_time}, comment=&#39;`Run Time` is timedelta object&#39;)
        else:
            # Return None or raise an exception if no total run time data is found
            return None


@AvailableBlocksOrca.register_block
class BlockOrcaTimingsForIndividualModules(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        match = re.search(
            &#39;^([ \\t]*Timings for individual modules:[ \\t]*)\\n&#39;, self.raw_data)

        body_start = match.end(1)
        header_raw = self.raw_data[:body_start]
        body_raw = self.raw_data[body_start:]

        return &#39;Timings for individual modules&#39;, header_raw, body_raw

    def data(self):
        # Initialize a dictionary to store the results
        timings_dict = {}

        # Define the regex pattern to match each module&#39;s timing information
        pattern = r&#34;([a-zA-Z ]+)\s+\.\.\.\s+([\d\.]+) sec&#34;

        # Find all matches in self.raw_data
        matches = re.findall(pattern, self.raw_data)

        # Process each match
        for module_name, time_sec in matches:
            # Convert time in seconds to a float
            time_sec = float(time_sec)

            # Convert time in seconds to a timedelta object
            module_time = timedelta(seconds=time_sec)

            # Add the module name and timedelta to the dictionary
            timings_dict[module_name.strip()] = module_time

        return Data(data=timings_dict, comment=&#39;Timings for different modules as timedelta objects&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orcaparse.orca_elements.AvailableBlocksOrca"><code class="flex name class">
<span>class <span class="ident">AvailableBlocksOrca</span></span>
</code></dt>
<dd>
<div class="desc"><p>A registry for managing different types of block elements.</p>
<p>This class maintains a dictionary of all available block types that can be dynamically extended. New block classes can be registered using the provided class methods, facilitating modularity and extensibility.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AvailableBlocksOrca(AvailableBlocksGeneral):
    blocks: dict[str, type[Element]] = {}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.AvailableBlocksGeneral" href="elements.html#orcaparse.elements.AvailableBlocksGeneral">AvailableBlocksGeneral</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.AvailableBlocksOrca.blocks"><code class="name">var <span class="ident">blocks</span> : dict[str, type[<a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.AvailableBlocksGeneral" href="elements.html#orcaparse.elements.AvailableBlocksGeneral">AvailableBlocksGeneral</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.AvailableBlocksGeneral.register_block" href="elements.html#orcaparse.elements.AvailableBlocksGeneral.register_block">register_block</a></code></li>
<li><code><a title="orcaparse.elements.AvailableBlocksGeneral.rewrite_block" href="elements.html#orcaparse.elements.AvailableBlocksGeneral.rewrite_block">rewrite_block</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaAllRightsReserved"><code class="flex name class">
<span>class <span class="ident">BlockOrcaAllRightsReserved</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaAllRightsReserved(Block):
    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;All Rights Reserved&#39;, None, self.raw_data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaDipoleMoment"><code class="flex name class">
<span>class <span class="ident">BlockOrcaDipoleMoment</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A specialized type of Block that expects a standard header format.</p>
<p>This class extends <code>Block</code> to handle cases where blocks of data include a standardized header section, marked by specific delimiter patterns. It provides a customized implementation of the <code>extract_name_header_and_body</code> method to parse such headers and separate the block into readable name, header, and body components.</p>
<p>The standard header format is expected to be delimited by lines of repeating special characters (e.g., '-', '*', '#') and may contain multiple lines of text that are considered part of the header.</p>
<p>Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaDipoleMoment(BlockOrcaWithStandardHeader):
    data_available: bool = True

    def data(self) -&gt; dict:
        # Initialize the result dictionary
        result = {}

        # Define regex pattern for lines with &#34;text: 3 numbers&#34;
        pattern_three_numbers = r&#34;([a-zA-Z \(\).]+):\s*(-?\d+\.\d+)\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)[ \t]*\n&#34;
        # Define regex pattern for lines with &#34;text: 1 number&#34;
        pattern_one_number = r&#34;([a-zA-Z \(\).]+):\s*(-?\d+\.\d+)[ \t]*(?:\n|\Z)&#34;

        # Find all matches for the three-number pattern
        matches_three_numbers = re.findall(
            pattern_three_numbers, self.raw_data)
        for match in matches_three_numbers:
            label, x, y, z = match
            result[label.strip()] = np.array([float(x), float(y), float(z)])

        # Find all matches for the one-number pattern
        matches_one_number = re.findall(pattern_one_number, self.raw_data)
        for match in matches_one_number:
            label, value = match
            if &#34;(Debye)&#34; in label:
                unit = &#34;Debye&#34;
            else:
                unit = &#34;a.u.&#34;
            result[label.strip()] = float(
                value)*ureg.debye if unit == &#34;Debye&#34; else float(value)

        return Data(data=result, comment=&#39;Numpy arrays of contributions, total dipole moment and pint object of `Magnitude (Debye)`.\nThe magnitude of the magnitude in Debye can be extracted from pint with .magnitude property.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></li>
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaDipoleMoment.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy"><code class="flex name class">
<span>class <span class="ident">BlockOrcaFinalSinglePointEnergy</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaFinalSinglePointEnergy(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;FINAL SINGLE POINT ENERGY&#39;, None, self.raw_data

    def data(self) -&gt; Data:
        &#39;&#39;&#39;
        returns FINAL SINGLE POINT ENERGY in Eh
        &#39;&#39;&#39;
        pattern = r&#34;FINAL SINGLE POINT ENERGY\s+(-?\d+\.\d+)&#34;

        # Search for the pattern in the text
        match = re.search(pattern, self.raw_data)

        if not match:
            raise ExtractionError(&#34;No energy match found in the data.&#34;)

        # Extract the floating-point number from the first capturing group
        energy = match.group(1)

        try:
            energy = float(energy) * ureg.Eh
            return Data(data={&#39;Energy&#39;: energy}, comment=&#39;`Energy` in pint format, to extract the value in Eh, use property .magnitude&#39;)
        except ValueError:
            raise ExtractionError(
                f&#34;Failed to convert the extracted energy {energy} to a floating-point number.&#34;)
        except Exception as e:
            # For any other unexpected exceptions, raise the original exception
            # You might want to log this exception or handle it differently depending on your application&#39;s needs
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> <a title="orcaparse.data.Data" href="data.html#orcaparse.data.Data">Data</a></span>
</code></dt>
<dd>
<div class="desc"><p>returns FINAL SINGLE POINT ENERGY in Eh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; Data:
    &#39;&#39;&#39;
    returns FINAL SINGLE POINT ENERGY in Eh
    &#39;&#39;&#39;
    pattern = r&#34;FINAL SINGLE POINT ENERGY\s+(-?\d+\.\d+)&#34;

    # Search for the pattern in the text
    match = re.search(pattern, self.raw_data)

    if not match:
        raise ExtractionError(&#34;No energy match found in the data.&#34;)

    # Extract the floating-point number from the first capturing group
    energy = match.group(1)

    try:
        energy = float(energy) * ureg.Eh
        return Data(data={&#39;Energy&#39;: energy}, comment=&#39;`Energy` in pint format, to extract the value in Eh, use property .magnitude&#39;)
    except ValueError:
        raise ExtractionError(
            f&#34;Failed to convert the extracted energy {energy} to a floating-point number.&#34;)
    except Exception as e:
        # For any other unexpected exceptions, raise the original exception
        # You might want to log this exception or handle it differently depending on your application&#39;s needs
        raise e</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaIcon"><code class="flex name class">
<span>class <span class="ident">BlockOrcaIcon</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaIcon(Block):
    data_available: bool = True

    def readable_name(self) -&gt; str:
        return &#39;Icon&#39;

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;Orca Icon&#39;, None, self.raw_data

    def data(self) -&gt; Data:
        &#39;&#39;&#39;
        Icon is icon, noting to extract except for the ascii symbols
        &#39;&#39;&#39;
        return Data(data={&#39;Icon&#39;: self.raw_data}, comment=&#34;Raw `Icon` string&#34;)

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;Orca Icon&#39;, None, self.raw_data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaIcon.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaIcon.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> <a title="orcaparse.data.Data" href="data.html#orcaparse.data.Data">Data</a></span>
</code></dt>
<dd>
<div class="desc"><p>Icon is icon, noting to extract except for the ascii symbols</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; Data:
    &#39;&#39;&#39;
    Icon is icon, noting to extract except for the ascii symbols
    &#39;&#39;&#39;
    return Data(data={&#39;Icon&#39;: self.raw_data}, comment=&#34;Raw `Icon` string&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaOrbitalEnergies"><code class="flex name class">
<span>class <span class="ident">BlockOrcaOrbitalEnergies</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A specialized type of Block that expects a standard header format.</p>
<p>This class extends <code>Block</code> to handle cases where blocks of data include a standardized header section, marked by specific delimiter patterns. It provides a customized implementation of the <code>extract_name_header_and_body</code> method to parse such headers and separate the block into readable name, header, and body components.</p>
<p>The standard header format is expected to be delimited by lines of repeating special characters (e.g., '-', '*', '#') and may contain multiple lines of text that are considered part of the header.</p>
<p>Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaOrbitalEnergies(BlockOrcaWithStandardHeader):
    data_available: bool = True

    def data(self) -&gt; dict[str, pd.DataFrame]:
        # Define regex pattern for extracting orbital data lines
        pattern_orbital_data = r&#34;\s*(\d+)\s+([0-1]\.\d{4})\s+(-?\d+\.\d+)\s+(-?\d+\.\d+)\s*&#34;

        # Split the raw data into lines
        lines = self.raw_data.split(&#39;\n&#39;)

        # Initialize containers for spin up and spin down data
        spin_up_data = []
        spin_down_data = []

        # Flag to switch between spin up and spin down data collection
        collecting_spin_down = False

        # Iterate over lines to fill spin_up_data and spin_down_data
        for line in lines:
            if &#34;SPIN UP ORBITALS&#34; in line:
                collecting_spin_down = False
                continue
            elif &#34;SPIN DOWN ORBITALS&#34; in line:
                collecting_spin_down = True
                continue

            match = re.match(pattern_orbital_data, line)
            if match:
                # Extract orbital data
                no, occ, e_eh, e_ev = match.groups()
                data_row = [int(no), float(occ), float(
                    e_eh) * ureg.Eh, float(e_ev) * ureg.eV]

                # Append to the correct list based on the current section
                if collecting_spin_down:
                    spin_down_data.append(data_row)
                else:
                    spin_up_data.append(data_row)

        # Convert lists to pandas DataFrames
        columns = [&#39;NO&#39;, &#39;OCC&#39;, &#39;E(Eh)&#39;, &#39;E(eV)&#39;]
        spin_up_df = pd.DataFrame(spin_up_data, columns=columns)
        spin_down_df = pd.DataFrame(spin_down_data, columns=columns)

        # Return a dictionary containing both DataFrames
        return Data(data={&#39;Spin Up&#39;: spin_up_df, &#39;Spin Down&#39;: spin_down_df}, comment=&#39;Pandas DataFrames `Spin Up` and `Spin Down`. Energy is represented by pint object. Magnitude cane be extracted with .magnitude property.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></li>
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaOrbitalEnergies.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaScfConverged"><code class="flex name class">
<span>class <span class="ident">BlockOrcaScfConverged</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaScfConverged(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;SCF convergence message&#39;, None, self.raw_data

    def data(self) -&gt; Data:
        # Check for the presence of &#34;SUCCESS&#34;
        success_match = re.search(r&#34;SUCCESS&#34;, self.raw_data)

        # Define regex pattern to match the number of cycles
        cycles_pattern = r&#34;(\d+)\s+CYCLES&#34;

        # Search for the cycles pattern in self.raw_data
        cycles_match = re.search(cycles_pattern, self.raw_data)

        # Prepare the result dictionary
        result = {
            # True if &#34;SUCCESS&#34; is found, False otherwise
            &#39;Success&#39;: bool(success_match),
            &#39;Cycles&#39;: None  # Default value for Cycles
        }

        # If a match for cycles is found, extract and update the number of cycles in the result dictionary
        if cycles_match:
            result[&#39;Cycles&#39;] = int(cycles_match.group(1))

        return Data(data=result, comment=&#39;bool for `Success` of the extraction and int for amount of `Cycles`&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaScfConverged.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaTerminatedNormally"><code class="flex name class">
<span>class <span class="ident">BlockOrcaTerminatedNormally</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaTerminatedNormally(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;ORCA TERMINATED NORMALLY&#39;, None, self.raw_data

    def data(self) -&gt; bool:
        &#39;&#39;&#39;
        returns True meaning that the block exists
        &#39;&#39;&#39;
        return Data(data={&#39;Termination status&#39;: True}, comment=&#39;`Termination status` is always `True`, otherwise you wound`t find this block.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaTerminatedNormally.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaTerminatedNormally.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>returns True meaning that the block exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; bool:
    &#39;&#39;&#39;
    returns True meaning that the block exists
    &#39;&#39;&#39;
    return Data(data={&#39;Termination status&#39;: True}, comment=&#39;`Termination status` is always `True`, otherwise you wound`t find this block.&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules"><code class="flex name class">
<span>class <span class="ident">BlockOrcaTimingsForIndividualModules</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaTimingsForIndividualModules(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        match = re.search(
            &#39;^([ \\t]*Timings for individual modules:[ \\t]*)\\n&#39;, self.raw_data)

        body_start = match.end(1)
        header_raw = self.raw_data[:body_start]
        body_raw = self.raw_data[body_start:]

        return &#39;Timings for individual modules&#39;, header_raw, body_raw

    def data(self):
        # Initialize a dictionary to store the results
        timings_dict = {}

        # Define the regex pattern to match each module&#39;s timing information
        pattern = r&#34;([a-zA-Z ]+)\s+\.\.\.\s+([\d\.]+) sec&#34;

        # Find all matches in self.raw_data
        matches = re.findall(pattern, self.raw_data)

        # Process each match
        for module_name, time_sec in matches:
            # Convert time in seconds to a float
            time_sec = float(time_sec)

            # Convert time in seconds to a timedelta object
            module_time = timedelta(seconds=time_sec)

            # Add the module name and timedelta to the dictionary
            timings_dict[module_name.strip()] = module_time

        return Data(data=timings_dict, comment=&#39;Timings for different modules as timedelta objects&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaTotalRunTime"><code class="flex name class">
<span>class <span class="ident">BlockOrcaTotalRunTime</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaTotalRunTime(Block):
    data_available: bool = True

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        return &#39;TOTAL RUN TIME&#39;, None, self.raw_data

    def data(self):
        # Define the regex pattern to match the total run time
        pattern = r&#34;TOTAL RUN TIME:\s*(\d+)\s*days\s*(\d+)\s*hours\s*(\d+)\s*minutes\s*(\d+)\s*seconds\s*(\d+)\s*msec&#34;

        # Search for the pattern in self.raw_data
        match = re.search(pattern, self.raw_data)

        # Check if a match is found
        if match:
            # Extract the components of the total run time
            days, hours, minutes, seconds, msec = match.groups()

            # Convert the extracted values to integers and milliseconds to seconds
            days = int(days)
            hours = int(hours)
            minutes = int(minutes)
            # Convert milliseconds to seconds
            seconds = int(seconds) + int(msec) / 1000.0

            # Create a timedelta object representing the total run time
            run_time = timedelta(days=days, hours=hours,
                                 minutes=minutes, seconds=seconds)

            return Data(data={&#39;Run Time&#39;: run_time}, comment=&#39;`Run Time` is timedelta object&#39;)
        else:
            # Return None or raise an exception if no total run time data is found
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaTotalRunTime.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaUnrecognizedMessage"><code class="flex name class">
<span>class <span class="ident">BlockOrcaUnrecognizedMessage</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaUnrecognizedMessage(Block):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaUnrecognizedNotification"><code class="flex name class">
<span>class <span class="ident">BlockOrcaUnrecognizedNotification</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaUnrecognizedNotification(Block):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="elements.html#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaUnrecognizedWithHeader"><code class="flex name class">
<span>class <span class="ident">BlockOrcaUnrecognizedWithHeader</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A specialized type of Block that expects a standard header format.</p>
<p>This class extends <code>Block</code> to handle cases where blocks of data include a standardized header section, marked by specific delimiter patterns. It provides a customized implementation of the <code>extract_name_header_and_body</code> method to parse such headers and separate the block into readable name, header, and body components.</p>
<p>The standard header format is expected to be delimited by lines of repeating special characters (e.g., '-', '*', '#') and may contain multiple lines of text that are considered part of the header.</p>
<p>Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaUnrecognizedWithHeader(BlockOrcaWithStandardHeader):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></li>
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.orca_elements.BlockOrcaWithStandardHeader"><code class="flex name class">
<span>class <span class="ident">BlockOrcaWithStandardHeader</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A specialized type of Block that expects a standard header format.</p>
<p>This class extends <code>Block</code> to handle cases where blocks of data include a standardized header section, marked by specific delimiter patterns. It provides a customized implementation of the <code>extract_name_header_and_body</code> method to parse such headers and separate the block into readable name, header, and body components.</p>
<p>The standard header format is expected to be delimited by lines of repeating special characters (e.g., '-', '*', '#') and may contain multiple lines of text that are considered part of the header.</p>
<p>Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@AvailableBlocksOrca.register_block
class BlockOrcaWithStandardHeader(Block):
    &#34;&#34;&#34;
    A specialized type of Block that expects a standard header format.

    This class extends `Block` to handle cases where blocks of data include a standardized header section, marked by specific delimiter patterns. It provides a customized implementation of the `extract_name_header_and_body` method to parse such headers and separate the block into readable name, header, and body components.

    The standard header format is expected to be delimited by lines of repeating special characters (e.g., &#39;-&#39;, &#39;*&#39;, &#39;#&#39;) and may contain multiple lines of text that are considered part of the header.
    &#34;&#34;&#34;

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        &#34;&#34;&#34;
        Extract the block&#39;s name, header, and body based on a standard header format.

        This method uses regular expressions to identify and separate the header section from the body. It then processes the header to extract a readable name and the header content itself. The remaining text is considered the body of the block.

        Returns:
            tuple[str, str | None, str]: A tuple containing the block&#39;s name, header (or None if not applicable), and body.

        Raises:
            Warning: If no recognizable header is found, indicating an unexpected format.
        &#34;&#34;&#34;
        # Define regex pattern to split header and body
        pattern = r&#34;^(([ \t]*[-*#]{7,}[ \t]*\n)(.*?)(\n[ \t]*[-*#]{7,}[ \t]*\n|$))&#34;

        # Search for the pattern in self.raw_data using re.DOTALL to make &#39;.&#39; match newlines
        match = re.search(pattern, self.raw_data, re.DOTALL)

        if match:
            # Header is the content between the first and second header delimiters

            # Body is the content after the second header delimiter
            # The end of the header delimiter is marked by the start of the body_raw
            body_start = match.end(1)
            header_raw = self.raw_data[:body_start]
            body_raw = self.raw_data[body_start:]

            readable_lines = []

            # Split the header into lines
            lines = header_raw.split(&#39;\n&#39;)

            # Iterate over lines to find readable content
            for line in lines:
                # Check if the line is not solely composed of whitespace or special symbols
                if not re.match(r&#34;^[ \t]*[-*#=]*[ \t]*$&#34;, line):
                    # Extract the central text if the line is surrounded by a maximum of one special symbol on each side
                    central_text_match = re.match(
                        r&#34;^[ \t]*[-*#=]{,1}[ \t]*(.*?)[ \t]*[-*#=]{,1}[ \t]*$&#34;, line)
                    if central_text_match:
                        # Check that something was found and collect the first group result
                        central_text = central_text_match.group(1).strip()
                        if central_text:  # Ensure central_text is not empty
                            readable_lines.append(central_text)

            # Combine readable lines into a single string
            readable_name = &#39; &#39;.join(readable_lines).strip()

            if len(readable_name) &lt; 2:
                warnings.warn(
                    f&#39;No readable name found in the header: {header_raw}&#39;)
                readable_name = Element.process_invalid_name(self.raw_data)

            return readable_name, header_raw, body_raw
        else:
            warnings.warn(
                f&#39;No header found in\n{self.raw_data}\n, and that is really weird as it was extracted based on the idea that there is a header in it&#39;)
            # If no match is found, put everything into header
            return Element.process_invalid_name(self.raw_data), None, self.raw_data</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="orcaparse.orca_elements.BlockOrcaDipoleMoment" href="#orcaparse.orca_elements.BlockOrcaDipoleMoment">BlockOrcaDipoleMoment</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaOrbitalEnergies" href="#orcaparse.orca_elements.BlockOrcaOrbitalEnergies">BlockOrcaOrbitalEnergies</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaUnrecognizedWithHeader" href="#orcaparse.orca_elements.BlockOrcaUnrecognizedWithHeader">BlockOrcaUnrecognizedWithHeader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body"><code class="name flex">
<span>def <span class="ident">extract_name_header_and_body</span></span>(<span>self) ‑> tuple[str, str | None, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the block's name, header, and body based on a standard header format.</p>
<p>This method uses regular expressions to identify and separate the header section from the body. It then processes the header to extract a readable name and the header content itself. The remaining text is considered the body of the block.</p>
<h2 id="returns">Returns</h2>
<p>tuple[str, str | None, str]: A tuple containing the block's name, header (or None if not applicable), and body.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Warning</code></dt>
<dd>If no recognizable header is found, indicating an unexpected format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
    &#34;&#34;&#34;
    Extract the block&#39;s name, header, and body based on a standard header format.

    This method uses regular expressions to identify and separate the header section from the body. It then processes the header to extract a readable name and the header content itself. The remaining text is considered the body of the block.

    Returns:
        tuple[str, str | None, str]: A tuple containing the block&#39;s name, header (or None if not applicable), and body.

    Raises:
        Warning: If no recognizable header is found, indicating an unexpected format.
    &#34;&#34;&#34;
    # Define regex pattern to split header and body
    pattern = r&#34;^(([ \t]*[-*#]{7,}[ \t]*\n)(.*?)(\n[ \t]*[-*#]{7,}[ \t]*\n|$))&#34;

    # Search for the pattern in self.raw_data using re.DOTALL to make &#39;.&#39; match newlines
    match = re.search(pattern, self.raw_data, re.DOTALL)

    if match:
        # Header is the content between the first and second header delimiters

        # Body is the content after the second header delimiter
        # The end of the header delimiter is marked by the start of the body_raw
        body_start = match.end(1)
        header_raw = self.raw_data[:body_start]
        body_raw = self.raw_data[body_start:]

        readable_lines = []

        # Split the header into lines
        lines = header_raw.split(&#39;\n&#39;)

        # Iterate over lines to find readable content
        for line in lines:
            # Check if the line is not solely composed of whitespace or special symbols
            if not re.match(r&#34;^[ \t]*[-*#=]*[ \t]*$&#34;, line):
                # Extract the central text if the line is surrounded by a maximum of one special symbol on each side
                central_text_match = re.match(
                    r&#34;^[ \t]*[-*#=]{,1}[ \t]*(.*?)[ \t]*[-*#=]{,1}[ \t]*$&#34;, line)
                if central_text_match:
                    # Check that something was found and collect the first group result
                    central_text = central_text_match.group(1).strip()
                    if central_text:  # Ensure central_text is not empty
                        readable_lines.append(central_text)

        # Combine readable lines into a single string
        readable_name = &#39; &#39;.join(readable_lines).strip()

        if len(readable_name) &lt; 2:
            warnings.warn(
                f&#39;No readable name found in the header: {header_raw}&#39;)
            readable_name = Element.process_invalid_name(self.raw_data)

        return readable_name, header_raw, body_raw
    else:
        warnings.warn(
            f&#39;No header found in\n{self.raw_data}\n, and that is really weird as it was extracted based on the idea that there is a header in it&#39;)
        # If no match is found, put everything into header
        return Element.process_invalid_name(self.raw_data), None, self.raw_data</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="elements.html#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="elements.html#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="elements.html#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="elements.html#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="elements.html#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="elements.html#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="elements.html#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="elements.html#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="elements.html#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="elements.html#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="elements.html#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="elements.html#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="elements.html#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orcaparse" href="index.html">orcaparse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orcaparse.orca_elements.AvailableBlocksOrca" href="#orcaparse.orca_elements.AvailableBlocksOrca">AvailableBlocksOrca</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.AvailableBlocksOrca.blocks" href="#orcaparse.orca_elements.AvailableBlocksOrca.blocks">blocks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaAllRightsReserved" href="#orcaparse.orca_elements.BlockOrcaAllRightsReserved">BlockOrcaAllRightsReserved</a></code></h4>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaDipoleMoment" href="#orcaparse.orca_elements.BlockOrcaDipoleMoment">BlockOrcaDipoleMoment</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaDipoleMoment.data_available" href="#orcaparse.orca_elements.BlockOrcaDipoleMoment.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy" href="#orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy">BlockOrcaFinalSinglePointEnergy</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy.data" href="#orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy.data">data</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy.data_available" href="#orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaIcon" href="#orcaparse.orca_elements.BlockOrcaIcon">BlockOrcaIcon</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaIcon.data" href="#orcaparse.orca_elements.BlockOrcaIcon.data">data</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaIcon.data_available" href="#orcaparse.orca_elements.BlockOrcaIcon.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaOrbitalEnergies" href="#orcaparse.orca_elements.BlockOrcaOrbitalEnergies">BlockOrcaOrbitalEnergies</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaOrbitalEnergies.data_available" href="#orcaparse.orca_elements.BlockOrcaOrbitalEnergies.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaScfConverged" href="#orcaparse.orca_elements.BlockOrcaScfConverged">BlockOrcaScfConverged</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaScfConverged.data_available" href="#orcaparse.orca_elements.BlockOrcaScfConverged.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaTerminatedNormally" href="#orcaparse.orca_elements.BlockOrcaTerminatedNormally">BlockOrcaTerminatedNormally</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaTerminatedNormally.data" href="#orcaparse.orca_elements.BlockOrcaTerminatedNormally.data">data</a></code></li>
<li><code><a title="orcaparse.orca_elements.BlockOrcaTerminatedNormally.data_available" href="#orcaparse.orca_elements.BlockOrcaTerminatedNormally.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules" href="#orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules">BlockOrcaTimingsForIndividualModules</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules.data_available" href="#orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaTotalRunTime" href="#orcaparse.orca_elements.BlockOrcaTotalRunTime">BlockOrcaTotalRunTime</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaTotalRunTime.data_available" href="#orcaparse.orca_elements.BlockOrcaTotalRunTime.data_available">data_available</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaUnrecognizedMessage" href="#orcaparse.orca_elements.BlockOrcaUnrecognizedMessage">BlockOrcaUnrecognizedMessage</a></code></h4>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaUnrecognizedNotification" href="#orcaparse.orca_elements.BlockOrcaUnrecognizedNotification">BlockOrcaUnrecognizedNotification</a></code></h4>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaUnrecognizedWithHeader" href="#orcaparse.orca_elements.BlockOrcaUnrecognizedWithHeader">BlockOrcaUnrecognizedWithHeader</a></code></h4>
</li>
<li>
<h4><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body" href="#orcaparse.orca_elements.BlockOrcaWithStandardHeader.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>