<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orcaparse.file API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orcaparse.file</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import re
import warnings
from typing import Optional

import pandas as pd
from typing_extensions import Iterable, Self

from .data import Data
from .elements import BlockUnknown, Element
from .regex_settings import (DEFAULT_GPAW_REGEX_SETTINGS,
                             DEFAULT_ORCA_REGEX_SETTINGS, RegexSettings)


class File:

    def __init__(self, file_path: str, regex_settings: Optional[RegexSettings] = None, mode: str = &#39;ORCA&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initializes the OrcaFile instance.

        Args:
            file_path (str): Path to the file to be processed.
            regex_settings (Optional[RegexSettings]): Custom regex settings for pattern processing. Defaults to None.
            mode (str): Mode of the file. Defaults to &#39;ORCA&#39;, can be &#39;ORCA&#39; or &#39;GPAW&#39;.

        Attributes:
            file_path (str): Path to the input file.
            regex_settings (RegexSettings): Regex settings used for pattern processing.
            initialized (bool): Flag indicating whether the instance has been initialized.
            original_text (str): The original text read from the file.
            _blocks (pd.DataFrame): DataFrame containing processed elements.
            _marked_text (list[tuple[tuple[int, int], tuple[int, int], str|Element]]): List of marked text segments. First tuple - char_position, second - line_position, third - text | Element.
            mode (str): Mode of the file, e.g., &#39;ORCA&#39; or &#39;GPAW&#39;.
        &#34;&#34;&#34;
        self.mode: str = mode
        self.file_path: str = file_path
        if regex_settings is None:
            if mode == &#39;ORCA&#39;:
                self.regex_settings = DEFAULT_ORCA_REGEX_SETTINGS
            elif mode == &#39;GPAW&#39;:
                self.regex_settings = DEFAULT_GPAW_REGEX_SETTINGS
            else:
                raise ValueError(
                    f&#34;Invalid mode &#39;{mode}&#39;. Must be &#39;ORCA&#39; or &#39;GPAW&#39;.&#34;)
        else:
            self.regex_settings: RegexSettings = regex_settings

        self.initialized: bool = False

        # Reading the content of the file.
        with open(self.file_path, &#34;r&#34;) as file:
            self.original_text: str = file.read()

        # Initializing the DataFrame to store OrcaElements.
        self._blocks: pd.DataFrame = pd.DataFrame(
            columns=[&#39;Type&#39;, &#39;Subtype&#39;, &#39;Element&#39;, &#39;CharPosition&#39; &#39;LinePosition&#39;])
        self._marked_text: list[tuple[tuple[int, int], tuple[int, int], str | Element]] = [
            ((0, len(self.original_text)),
             (1, self.original_text.count(&#39;\n&#39;) + 1), self.original_text)
        ]

    def get_structure(self) -&gt; dict[Self, tuple | None]:
        &#39;&#39;&#39;
            Structure in a form of nested dict
        &#39;&#39;&#39;
        blocks = self.get_blocks()
        return [self, list(blocks[&#39;Element&#39;].apply(lambda x: x.get_structure()))]

    def depth(self) -&gt; int:
        return Element.max_depth(self.get_structure())

    def get_blocks(self, show_progress: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the DataFrame containing all processed blocks.

        Ensures initialization has occurred before returning the blocks.

        Returns:
            pd.DataFrame: DataFrame containing the processed blocks.
        &#34;&#34;&#34;
        self.initialize(show_progress=show_progress)
        return self._blocks

    def get_marked_text(self, show_progress: bool = False) -&gt; list[tuple[tuple[int, int], tuple[int, int], Element]]:
        &#34;&#34;&#34;
        Returns the text with markers after processing patterns.

        Ensures initialization has occurred before returning the marked text.

        Returns:
            str: The marked text.
        &#34;&#34;&#34;
        self.initialize(show_progress=show_progress)
        return self._marked_text

    def initialize(self, show_progress: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Initializes the instance by processing patterns if not already done.

        This method sets `self.initialized` to True after processing to avoid redundant initializations.
        &#34;&#34;&#34;
        if not self.initialized:
            self.process_patterns(show_progress=show_progress)
            self.initialized = True

    def process_patterns(self, show_progress=False):
        &#34;&#34;&#34;
        Processes the regex patterns defined in the OrcaFile&#39;s regex settings to identify, extract, and
        instantiate OrcaElements from the file&#39;s text. It updates the internal _blocks DataFrame with the
        extracted elements and their metadata, and replaces identified patterns in the text with unique markers.

        This method performs several steps:
        1. Resets the _blocks DataFrame to ensure it&#39;s ready for new data.
        2. Iterates over each regex pattern defined in the file&#39;s regex settings.
        3. Uses each pattern to search through the original text, identifying matches.
        4. For each match, extracts relevant data and uses it to instantiate the corresponding OrcaElement subclass.
        5. Generates a unique ID for each extracted element and uses it to replace the original text with a marker.
        6. Updates the _blocks DataFrame with new rows containing the element data, type, subtype, and its position within the text.
        7. Replaces identified patterns in the text with markers that include the type, subtype, and unique ID of the extracted elements.

        Upon completion, the text is fully processed, with all elements identified.
        &#34;&#34;&#34;
        self._blocks = pd.DataFrame(
            columns=[&#39;Type&#39;, &#39;Subtype&#39;, &#39;Element&#39;, &#39;CharPosition&#39;, &#39;LinePosition&#39;])
        self._marked_text: list[tuple[tuple[int, int], tuple[int, int], str | Element]] = [
            ((0, len(self.original_text)),
             (1, self.original_text.count(&#39;\n&#39;) + 1), self.original_text)
        ]

        self.initialized = True

        for regex in self.regex_settings.to_list():
            self._marked_text, new_blocks = regex.apply(
                self._marked_text, mode=self.mode, show_progress=show_progress)
            new_blocks_df = pd.DataFrame.from_dict(new_blocks, orient=&#34;index&#34;)
            new_blocks_df[&#39;Type&#39;] = regex.p_type
            new_blocks_df[&#39;Subtype&#39;] = regex.p_subtype
            self._blocks = pd.concat([self._blocks, new_blocks_df])

        unknown_blocks = {}

        for i, (char_position, line_position, block) in enumerate(self._marked_text):
            if isinstance(block, str):
                unknown_block = BlockUnknown(
                    block, char_position=char_position, line_position=line_position)
                self._marked_text[i] = (
                    char_position, line_position, unknown_block)
                unknown_blocks[hash(unknown_block)] = {
                    &#39;Element&#39;: unknown_block, &#39;CharPosition&#39;: char_position, &#39;LinePosition&#39;: line_position}

        unknown_blocks_df = pd.DataFrame.from_dict(
            unknown_blocks, orient=&#34;index&#34;)
        unknown_blocks_df[&#39;Type&#39;] = &#39;Block&#39;
        unknown_blocks_df[&#39;Subtype&#39;] = &#39;BlockUnknown&#39;

        self._blocks = pd.concat([self._blocks, unknown_blocks_df])

    @staticmethod
    def extract_raw_data_errors_to_none(orca_element: Element) -&gt; str | None:
        &#34;&#34;&#34;
        Attempts to extract data from an OrcaElement, handling any errors by returning None.

        This nested function is designed to be applied to each row of the DataFrame, specifically to each
        OrcaElement in the &#39;Element&#39; column. It encapsulates the error-handling logic, ensuring that any
        exceptions raised during data extraction are caught and processed appropriately.

        Parameters:
            orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.

        Returns:
            The extracted data from the OrcaElement, or None if an error occurred during the extraction process.
        &#34;&#34;&#34;
        try:
            # return Data(orca_element.data())
            return orca_element.raw_data
        except Exception as e:
            warnings.warn(
                f&#34;An unexpected error occurred while extracting raw_data from {orca_element}: {e}, returning None instead of data.\n That is really weird&#34;)
            return None

    @staticmethod
    def extract_data_errors_to_none(orca_element: Element) -&gt; Data | None:
        &#34;&#34;&#34;
        Attempts to extract data from an OrcaElement, handling any errors by returning None.

        This nested function is designed to be applied to each row of the DataFrame, specifically to each
        OrcaElement in the &#39;Element&#39; column. It encapsulates the error-handling logic, ensuring that any
        exceptions raised during data extraction are caught and processed appropriately.

        Parameters:
            orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.

        Returns:
            The extracted data from the OrcaElement in orcaparse.Data format, or None if an error occurred during the extraction process.
        &#34;&#34;&#34;
        try:
            # return Data(orca_element.data())
            return orca_element.data()
        except Exception as e:
            warnings.warn(
                f&#34;An unexpected error occurred while extracting data from {orca_element}: {e}, returning None instead of data.\n Raw context of the element is {orca_element.raw_data}&#34;)
            return None

    def search_elements(self, element_type: type[Element] | None = None, readable_name: str | None = None, raw_data_substring: str | Iterable[str] | None = None, raw_data_not_substring: str | Iterable[str] | None = None, show_progress: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Searches for OrcaElement instances based on various criteria.

        Parameters:
            element_type (type[Element], optional): The class type of the OrcaElement to search for.
            readable_name (str, optional): The exact term to search for in the readable_name attribute.
            raw_data_substring (str, Iterable[str], optional): The substring to search for within the raw_data attribute.
            raw_data_not_substring (str, Iterable[str], optional): The substring to search the absence of within the raw_data attribute.

        Returns:
            pd.DataFrame: A DataFrame containing the filtered OrcaElements based on the provided criteria.
        &#34;&#34;&#34;
        self.initialize(show_progress=show_progress)
        blocks_copy = self._blocks.copy()
        blocks_copy[&#39;ReadableName&#39;] = blocks_copy[&#39;Element&#39;].apply(
            lambda x: x.readable_name())
        blocks_copy[&#39;RawData&#39;] = blocks_copy[&#39;Element&#39;].apply(
            lambda x: self.extract_raw_data_errors_to_none(x))

        if element_type is not None and len(blocks_copy) &gt; 0:
            blocks_copy = blocks_copy[blocks_copy[&#39;Element&#39;].apply(
                lambda x: isinstance(x, element_type))]

        if readable_name is not None and len(blocks_copy) &gt; 0:

            blocks_copy = blocks_copy[blocks_copy[&#39;ReadableName&#39;]
                                      == readable_name]

        if raw_data_substring is not None and len(blocks_copy) &gt; 0:
            def contains_all_substrings(x_raw_data, substrings):
                # If substrings is a string, convert it to a list for uniformity
                if isinstance(substrings, str):
                    substrings = [substrings]

                # Check if all elements in substrings are in x_raw_data
                return all(substring in x_raw_data for substring in substrings)

            # Filter rows where all substrings are present in the RawData
            matches = blocks_copy[&#39;RawData&#39;].apply(
                lambda x: contains_all_substrings(x, raw_data_substring))
            blocks_copy = blocks_copy[matches]

        if raw_data_not_substring is not None and len(blocks_copy) &gt; 0:
            def contains_no_substrings(x_raw_data, substrings):
                # If substrings is a string, convert it to a list for uniformity
                if isinstance(substrings, str):
                    substrings = [substrings]

                # Check if all elements in substrings are not in x_raw_data
                return all(substring not in x_raw_data for substring in substrings)

            # Filter rows where all substrings are not present in the RawData
            matches = blocks_copy[&#39;RawData&#39;].apply(
                lambda x: contains_no_substrings(x, raw_data_not_substring))
            blocks_copy = blocks_copy[matches]

        return blocks_copy

    def get_data(self, extract_only_raw: bool = False, element_type: type[Element] | None = None, readable_name: str | None = None, raw_data_substring: str | Iterable[str] | None = None, raw_data_not_substring: str | Iterable[str] | None = None, show_progress: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Retrieves and extracts data or raw data strings from OrcaElement instances based on specified search criteria and extraction type.

        This method first searches for OrcaElement instances based on the provided search criteria, which can include the element&#39;s type, readable name, or a substring of its raw data. After filtering the elements, it extracts either raw data strings or processed data from them, depending on the &#39;extract_raw&#39; flag.

        Parameters:
            extract_ony_raw (bool, optional): Determines if `ExtractedData` will be additionally created. If True, it will not. Raw data is stored in `RawData`. Defaults to False.
            element_type (type[Element] | None, optional): The class type of the OrcaElements to filter by. Only elements that are instances of this type or derived from it will be included. Defaults to None, which skips this filter.
            readable_name (str | None, optional): The exact name to match against the &#39;readable_name&#39; attribute of OrcaElements. Only elements with a matching readable name are included. Defaults to None, which skips this filter.
            raw_data_substring (str | Iterable[str] | None, optional): A substring to search for within the &#39;raw_data&#39; attribute of OrcaElements. Only elements whose raw data contains this substring are included. Defaults to None, which skips this filter.
            raw_data_not_substring (str | Iterable[str] | None, optional): A substring to search for within the &#39;raw_data&#39; attribute of OrcaElements. The elements whose raw data contains this substring are not included. Defaults to None, which skips this filter.
            show_progress (bool, optional): Determines if a progress bar is displayed when extracting data from elements. Defaults to False.

        Returns:
            pd.DataFrame: A DataFrame containing the extracted data or raw data strings from the filtered OrcaElements. The DataFrame includes an &#39;ExtractedData&#39; column with the extracted information. If no elements match the search criteria, an empty DataFrame is returned.
        &#34;&#34;&#34;
        blocks = self.search_elements(element_type=element_type,
                                      readable_name=readable_name,
                                      raw_data_substring=raw_data_substring,
                                      raw_data_not_substring=raw_data_not_substring,
                                      show_progress=show_progress)
        if not extract_only_raw:
            # Implement the logic to extract processed data from blocks
            extracted_data = blocks[&#39;Element&#39;].apply(
                lambda x: self.extract_data_errors_to_none(x))
            blocks[&#39;ExtractedData&#39;] = extracted_data
        return blocks

    def create_html(self, css_content: str | None = None, js_content: str | None = None, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Generates a complete HTML document from the processed text, incorporating optional CSS and JavaScript content.

        This method operates in several key steps:
        1. It first ensures that CSS and JavaScript content are set, either to the provided arguments or to default values.
        2. The method then retrieves the processed text with markers using the `get_marked_text` method.
        3. A nested function `replace_marker_with_html` is defined to handle the replacement of each marker within the text
        with the corresponding HTML content generated from the associated OrcaElement. This function:
        - Extracts the type, subtype, and unique ID from each marker.
        - Retrieves the corresponding OrcaElement from the _blocks DataFrame using the unique ID.
        - Calls the `to_html` method on the OrcaElement to generate its HTML representation.
        4. A regular expression is used to find all markers in the processed text, and the `replace_marker_with_html` function
        is applied to replace each marker with its HTML content.
        5. The full HTML document is assembled using the provided or default CSS and JavaScript, along with the body content
        that now includes the HTML representations of the OrcaElements.

        Parameters:
            css_content (str | None): Optional CSS content to include in the &lt;style&gt; tag of the HTML document. If None,
                                    a default CSS content is used.
            js_content (str | None): Optional JavaScript content to include in a &lt;script&gt; tag at the end of the document.
                                    If None, default JavaScript content is used.

        Returns:
            str: A string containing the complete HTML document.

        Raises:
            Exception: If an OrcaElement referenced by a marker cannot be found in the _blocks DataFrame, an exception is raised.

        Note:
            The HTML document includes a structure with a container div, a sidebar for a table of contents (TOC),
            a comment sidebar for additional annotations, and a content area where the main body content is placed.
            The TOC and comment sidebar are expected to be populated by the provided JavaScript.
        &#34;&#34;&#34;
        if css_content is None:
            # Get the directory of this file
            directory = os.path.dirname(__file__)
            # Construct the path to default.css
            css_file = os.path.join(directory, &#39;default.css&#39;)
            with open(css_file, &#34;r&#34;) as file:
                css_content = file.read()

        if js_content is None:
            # Get the directory of this file
            directory = os.path.dirname(__file__)
            # Construct the path to default.js
            js_file = os.path.join(directory, &#39;default.js&#39;)
            with open(js_file, &#34;r&#34;) as file:
                js_content = file.read()

        # Process the text to ensure all elements are captured
        processed_text = self.get_marked_text(show_progress=show_progress)

        body_content = &#39;&#39;.join(element[2].to_html()
                               for element in processed_text)

        # Construct the full HTML Document with CSS and JS if requested
        html_content = &#34;&lt;!DOCTYPE html&gt;\n&#34;
        html_content += &#34;&lt;html lang=\&#34;en\&#34;&gt;\n&lt;head&gt;\n&#34;
        html_content += &#34;    &lt;meta charset=\&#34;UTF-8\&#34;&gt;\n&#34;
        html_content += &#34;    &lt;meta name=\&#34;viewport\&#34; content=\&#34;width=device-width, initial-scale=1.0\&#34;&gt;\n&#34;
        html_content += &#34;    &lt;title&gt;ORCA&lt;/title&gt;\n&#34;

        if insert_css:
            html_content += &#34;    &lt;style&gt;\n        &#34; + \
                (css_content if css_content else &#34;&#34;) + &#34;\n    &lt;/style&gt;\n&#34;

        html_content += &#34;&lt;/head&gt;\n&lt;body&gt;\n&#34;
        html_content += &#34;    &lt;div class=\&#34;container\&#34;&gt;\n&#34;

        if insert_left_sidebar:
            html_content += &#34;        &lt;div class=\&#34;sidebar\&#34;&gt;\n&#34;
            html_content += &#34;            &lt;!-- Left sidebar content (TOC) --&gt;\n&#34;
            html_content += &#34;            &lt;div class=\&#34;toc\&#34;&gt;\n    &lt;!-- JavaScript will populate this area --&gt;\n&lt;/div&gt;&#34;
            html_content += &#34;        &lt;/div&gt;\n&#34;

        if insert_colorcomment_sidebar:
            html_content += &#34;        &lt;div class=\&#34;comment-sidebar\&#34;&gt;\n&#34;
            html_content += &#34;            &lt;!-- comment sidebar for color-comment sections --&gt;\n&#34;
            html_content += &#34;            &lt;!-- JavaScript will populate this area --&gt;\n        &lt;/div&gt;\n&#34;

        html_content += &#34;        &lt;div class=\&#34;content\&#34;&gt;\n            &#34; + \
            body_content + &#34;\n        &lt;/div&gt;\n&#34;
        html_content += &#34;    &lt;/div&gt;\n&#34;

        if insert_js:
            html_content += &#34;    &lt;script&gt;\n        &#34; + \
                (js_content if js_content else &#34;&#34;) + &#34;\n    &lt;/script&gt;\n&#34;

        html_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        return html_content

    def save_as_html(self, output_file_path: str, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress=False):
        &#34;&#34;&#34;
        Generates an HTML document from the OrcaFile instance with customizable options and saves it to the specified file path.

        This method performs the following actions:
        1. Calls the `create_html` method to generate the complete HTML content based on the processed text, optional CSS and JavaScript content, and conditional inclusion of the left sidebar (TOC) and the color-comment sidebar. The `create_html` method assembles the HTML document, incorporating the specified elements and transforms markers within the text into corresponding HTML elements.
        2. Opens the specified output file in write mode. If the file does not exist, it will be created; if it already exists, its content will be overwritten.
        3. Writes the generated HTML content to the file, effectively saving the entire content of the OrcaFile instance as an HTML document at the specified location.

        Parameters:
            output_file_path (str): The file path where the HTML document should be saved. This path includes the file name and extension, for example, &#39;output/document.html&#39;.
            insert_css (bool, optional): Specifies whether CSS content should be included in the HTML document. Defaults to True.
            insert_js (bool, optional): Specifies whether JavaScript content should be included in the HTML document. Defaults to True.
            insert_left_sidebar (bool, optional): Specifies whether a left sidebar for the Table of Contents (TOC) should be included in the HTML document. Defaults to True.
            insert_colorcomment_sidebar (bool, optional): Specifies whether a comment sidebar for additional annotations should be included in the HTML document. Defaults to True.

        Note:
            This method provides a flexible way to export the content of an OrcaFile instance to a standard HTML format, making it accessible for viewing in web browsers or for further processing with tools that accept HTML input. It allows for the customization of the exported HTML document through parameters that control the inclusion of CSS, JavaScript, and additional structural elements like sidebars.
        &#34;&#34;&#34;
        html_content = self.create_html(insert_css=insert_css, insert_js=insert_js,
                                        insert_left_sidebar=insert_left_sidebar, insert_colorcomment_sidebar=insert_colorcomment_sidebar, show_progress=show_progress)

        with open(output_file_path, &#39;w&#39;) as output_file:
            output_file.write(html_content)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orcaparse.file.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>file_path: str, regex_settings: Optional[<a title="orcaparse.regex_settings.RegexSettings" href="regex_settings.html#orcaparse.regex_settings.RegexSettings">RegexSettings</a>] = None, mode: str = 'ORCA')</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the OrcaFile instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file to be processed.</dd>
<dt><strong><code>regex_settings</code></strong> :&ensp;<code>Optional[RegexSettings]</code></dt>
<dd>Custom regex settings for pattern processing. Defaults to None.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Mode of the file. Defaults to 'ORCA', can be 'ORCA' or 'GPAW'.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the input file.</dd>
<dt><strong><code>regex_settings</code></strong> :&ensp;<code>RegexSettings</code></dt>
<dd>Regex settings used for pattern processing.</dd>
<dt><strong><code>initialized</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag indicating whether the instance has been initialized.</dd>
<dt><strong><code>original_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The original text read from the file.</dd>
<dt><strong><code>_blocks</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>DataFrame containing processed elements.</dd>
<dt>_marked_text (list[tuple[tuple[int, int], tuple[int, int], str|Element]]): List of marked text segments. First tuple - char_position, second - line_position, third - text | Element.</dt>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Mode of the file, e.g., 'ORCA' or 'GPAW'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File:

    def __init__(self, file_path: str, regex_settings: Optional[RegexSettings] = None, mode: str = &#39;ORCA&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initializes the OrcaFile instance.

        Args:
            file_path (str): Path to the file to be processed.
            regex_settings (Optional[RegexSettings]): Custom regex settings for pattern processing. Defaults to None.
            mode (str): Mode of the file. Defaults to &#39;ORCA&#39;, can be &#39;ORCA&#39; or &#39;GPAW&#39;.

        Attributes:
            file_path (str): Path to the input file.
            regex_settings (RegexSettings): Regex settings used for pattern processing.
            initialized (bool): Flag indicating whether the instance has been initialized.
            original_text (str): The original text read from the file.
            _blocks (pd.DataFrame): DataFrame containing processed elements.
            _marked_text (list[tuple[tuple[int, int], tuple[int, int], str|Element]]): List of marked text segments. First tuple - char_position, second - line_position, third - text | Element.
            mode (str): Mode of the file, e.g., &#39;ORCA&#39; or &#39;GPAW&#39;.
        &#34;&#34;&#34;
        self.mode: str = mode
        self.file_path: str = file_path
        if regex_settings is None:
            if mode == &#39;ORCA&#39;:
                self.regex_settings = DEFAULT_ORCA_REGEX_SETTINGS
            elif mode == &#39;GPAW&#39;:
                self.regex_settings = DEFAULT_GPAW_REGEX_SETTINGS
            else:
                raise ValueError(
                    f&#34;Invalid mode &#39;{mode}&#39;. Must be &#39;ORCA&#39; or &#39;GPAW&#39;.&#34;)
        else:
            self.regex_settings: RegexSettings = regex_settings

        self.initialized: bool = False

        # Reading the content of the file.
        with open(self.file_path, &#34;r&#34;) as file:
            self.original_text: str = file.read()

        # Initializing the DataFrame to store OrcaElements.
        self._blocks: pd.DataFrame = pd.DataFrame(
            columns=[&#39;Type&#39;, &#39;Subtype&#39;, &#39;Element&#39;, &#39;CharPosition&#39; &#39;LinePosition&#39;])
        self._marked_text: list[tuple[tuple[int, int], tuple[int, int], str | Element]] = [
            ((0, len(self.original_text)),
             (1, self.original_text.count(&#39;\n&#39;) + 1), self.original_text)
        ]

    def get_structure(self) -&gt; dict[Self, tuple | None]:
        &#39;&#39;&#39;
            Structure in a form of nested dict
        &#39;&#39;&#39;
        blocks = self.get_blocks()
        return [self, list(blocks[&#39;Element&#39;].apply(lambda x: x.get_structure()))]

    def depth(self) -&gt; int:
        return Element.max_depth(self.get_structure())

    def get_blocks(self, show_progress: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Returns the DataFrame containing all processed blocks.

        Ensures initialization has occurred before returning the blocks.

        Returns:
            pd.DataFrame: DataFrame containing the processed blocks.
        &#34;&#34;&#34;
        self.initialize(show_progress=show_progress)
        return self._blocks

    def get_marked_text(self, show_progress: bool = False) -&gt; list[tuple[tuple[int, int], tuple[int, int], Element]]:
        &#34;&#34;&#34;
        Returns the text with markers after processing patterns.

        Ensures initialization has occurred before returning the marked text.

        Returns:
            str: The marked text.
        &#34;&#34;&#34;
        self.initialize(show_progress=show_progress)
        return self._marked_text

    def initialize(self, show_progress: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Initializes the instance by processing patterns if not already done.

        This method sets `self.initialized` to True after processing to avoid redundant initializations.
        &#34;&#34;&#34;
        if not self.initialized:
            self.process_patterns(show_progress=show_progress)
            self.initialized = True

    def process_patterns(self, show_progress=False):
        &#34;&#34;&#34;
        Processes the regex patterns defined in the OrcaFile&#39;s regex settings to identify, extract, and
        instantiate OrcaElements from the file&#39;s text. It updates the internal _blocks DataFrame with the
        extracted elements and their metadata, and replaces identified patterns in the text with unique markers.

        This method performs several steps:
        1. Resets the _blocks DataFrame to ensure it&#39;s ready for new data.
        2. Iterates over each regex pattern defined in the file&#39;s regex settings.
        3. Uses each pattern to search through the original text, identifying matches.
        4. For each match, extracts relevant data and uses it to instantiate the corresponding OrcaElement subclass.
        5. Generates a unique ID for each extracted element and uses it to replace the original text with a marker.
        6. Updates the _blocks DataFrame with new rows containing the element data, type, subtype, and its position within the text.
        7. Replaces identified patterns in the text with markers that include the type, subtype, and unique ID of the extracted elements.

        Upon completion, the text is fully processed, with all elements identified.
        &#34;&#34;&#34;
        self._blocks = pd.DataFrame(
            columns=[&#39;Type&#39;, &#39;Subtype&#39;, &#39;Element&#39;, &#39;CharPosition&#39;, &#39;LinePosition&#39;])
        self._marked_text: list[tuple[tuple[int, int], tuple[int, int], str | Element]] = [
            ((0, len(self.original_text)),
             (1, self.original_text.count(&#39;\n&#39;) + 1), self.original_text)
        ]

        self.initialized = True

        for regex in self.regex_settings.to_list():
            self._marked_text, new_blocks = regex.apply(
                self._marked_text, mode=self.mode, show_progress=show_progress)
            new_blocks_df = pd.DataFrame.from_dict(new_blocks, orient=&#34;index&#34;)
            new_blocks_df[&#39;Type&#39;] = regex.p_type
            new_blocks_df[&#39;Subtype&#39;] = regex.p_subtype
            self._blocks = pd.concat([self._blocks, new_blocks_df])

        unknown_blocks = {}

        for i, (char_position, line_position, block) in enumerate(self._marked_text):
            if isinstance(block, str):
                unknown_block = BlockUnknown(
                    block, char_position=char_position, line_position=line_position)
                self._marked_text[i] = (
                    char_position, line_position, unknown_block)
                unknown_blocks[hash(unknown_block)] = {
                    &#39;Element&#39;: unknown_block, &#39;CharPosition&#39;: char_position, &#39;LinePosition&#39;: line_position}

        unknown_blocks_df = pd.DataFrame.from_dict(
            unknown_blocks, orient=&#34;index&#34;)
        unknown_blocks_df[&#39;Type&#39;] = &#39;Block&#39;
        unknown_blocks_df[&#39;Subtype&#39;] = &#39;BlockUnknown&#39;

        self._blocks = pd.concat([self._blocks, unknown_blocks_df])

    @staticmethod
    def extract_raw_data_errors_to_none(orca_element: Element) -&gt; str | None:
        &#34;&#34;&#34;
        Attempts to extract data from an OrcaElement, handling any errors by returning None.

        This nested function is designed to be applied to each row of the DataFrame, specifically to each
        OrcaElement in the &#39;Element&#39; column. It encapsulates the error-handling logic, ensuring that any
        exceptions raised during data extraction are caught and processed appropriately.

        Parameters:
            orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.

        Returns:
            The extracted data from the OrcaElement, or None if an error occurred during the extraction process.
        &#34;&#34;&#34;
        try:
            # return Data(orca_element.data())
            return orca_element.raw_data
        except Exception as e:
            warnings.warn(
                f&#34;An unexpected error occurred while extracting raw_data from {orca_element}: {e}, returning None instead of data.\n That is really weird&#34;)
            return None

    @staticmethod
    def extract_data_errors_to_none(orca_element: Element) -&gt; Data | None:
        &#34;&#34;&#34;
        Attempts to extract data from an OrcaElement, handling any errors by returning None.

        This nested function is designed to be applied to each row of the DataFrame, specifically to each
        OrcaElement in the &#39;Element&#39; column. It encapsulates the error-handling logic, ensuring that any
        exceptions raised during data extraction are caught and processed appropriately.

        Parameters:
            orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.

        Returns:
            The extracted data from the OrcaElement in orcaparse.Data format, or None if an error occurred during the extraction process.
        &#34;&#34;&#34;
        try:
            # return Data(orca_element.data())
            return orca_element.data()
        except Exception as e:
            warnings.warn(
                f&#34;An unexpected error occurred while extracting data from {orca_element}: {e}, returning None instead of data.\n Raw context of the element is {orca_element.raw_data}&#34;)
            return None

    def search_elements(self, element_type: type[Element] | None = None, readable_name: str | None = None, raw_data_substring: str | Iterable[str] | None = None, raw_data_not_substring: str | Iterable[str] | None = None, show_progress: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Searches for OrcaElement instances based on various criteria.

        Parameters:
            element_type (type[Element], optional): The class type of the OrcaElement to search for.
            readable_name (str, optional): The exact term to search for in the readable_name attribute.
            raw_data_substring (str, Iterable[str], optional): The substring to search for within the raw_data attribute.
            raw_data_not_substring (str, Iterable[str], optional): The substring to search the absence of within the raw_data attribute.

        Returns:
            pd.DataFrame: A DataFrame containing the filtered OrcaElements based on the provided criteria.
        &#34;&#34;&#34;
        self.initialize(show_progress=show_progress)
        blocks_copy = self._blocks.copy()
        blocks_copy[&#39;ReadableName&#39;] = blocks_copy[&#39;Element&#39;].apply(
            lambda x: x.readable_name())
        blocks_copy[&#39;RawData&#39;] = blocks_copy[&#39;Element&#39;].apply(
            lambda x: self.extract_raw_data_errors_to_none(x))

        if element_type is not None and len(blocks_copy) &gt; 0:
            blocks_copy = blocks_copy[blocks_copy[&#39;Element&#39;].apply(
                lambda x: isinstance(x, element_type))]

        if readable_name is not None and len(blocks_copy) &gt; 0:

            blocks_copy = blocks_copy[blocks_copy[&#39;ReadableName&#39;]
                                      == readable_name]

        if raw_data_substring is not None and len(blocks_copy) &gt; 0:
            def contains_all_substrings(x_raw_data, substrings):
                # If substrings is a string, convert it to a list for uniformity
                if isinstance(substrings, str):
                    substrings = [substrings]

                # Check if all elements in substrings are in x_raw_data
                return all(substring in x_raw_data for substring in substrings)

            # Filter rows where all substrings are present in the RawData
            matches = blocks_copy[&#39;RawData&#39;].apply(
                lambda x: contains_all_substrings(x, raw_data_substring))
            blocks_copy = blocks_copy[matches]

        if raw_data_not_substring is not None and len(blocks_copy) &gt; 0:
            def contains_no_substrings(x_raw_data, substrings):
                # If substrings is a string, convert it to a list for uniformity
                if isinstance(substrings, str):
                    substrings = [substrings]

                # Check if all elements in substrings are not in x_raw_data
                return all(substring not in x_raw_data for substring in substrings)

            # Filter rows where all substrings are not present in the RawData
            matches = blocks_copy[&#39;RawData&#39;].apply(
                lambda x: contains_no_substrings(x, raw_data_not_substring))
            blocks_copy = blocks_copy[matches]

        return blocks_copy

    def get_data(self, extract_only_raw: bool = False, element_type: type[Element] | None = None, readable_name: str | None = None, raw_data_substring: str | Iterable[str] | None = None, raw_data_not_substring: str | Iterable[str] | None = None, show_progress: bool = False) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Retrieves and extracts data or raw data strings from OrcaElement instances based on specified search criteria and extraction type.

        This method first searches for OrcaElement instances based on the provided search criteria, which can include the element&#39;s type, readable name, or a substring of its raw data. After filtering the elements, it extracts either raw data strings or processed data from them, depending on the &#39;extract_raw&#39; flag.

        Parameters:
            extract_ony_raw (bool, optional): Determines if `ExtractedData` will be additionally created. If True, it will not. Raw data is stored in `RawData`. Defaults to False.
            element_type (type[Element] | None, optional): The class type of the OrcaElements to filter by. Only elements that are instances of this type or derived from it will be included. Defaults to None, which skips this filter.
            readable_name (str | None, optional): The exact name to match against the &#39;readable_name&#39; attribute of OrcaElements. Only elements with a matching readable name are included. Defaults to None, which skips this filter.
            raw_data_substring (str | Iterable[str] | None, optional): A substring to search for within the &#39;raw_data&#39; attribute of OrcaElements. Only elements whose raw data contains this substring are included. Defaults to None, which skips this filter.
            raw_data_not_substring (str | Iterable[str] | None, optional): A substring to search for within the &#39;raw_data&#39; attribute of OrcaElements. The elements whose raw data contains this substring are not included. Defaults to None, which skips this filter.
            show_progress (bool, optional): Determines if a progress bar is displayed when extracting data from elements. Defaults to False.

        Returns:
            pd.DataFrame: A DataFrame containing the extracted data or raw data strings from the filtered OrcaElements. The DataFrame includes an &#39;ExtractedData&#39; column with the extracted information. If no elements match the search criteria, an empty DataFrame is returned.
        &#34;&#34;&#34;
        blocks = self.search_elements(element_type=element_type,
                                      readable_name=readable_name,
                                      raw_data_substring=raw_data_substring,
                                      raw_data_not_substring=raw_data_not_substring,
                                      show_progress=show_progress)
        if not extract_only_raw:
            # Implement the logic to extract processed data from blocks
            extracted_data = blocks[&#39;Element&#39;].apply(
                lambda x: self.extract_data_errors_to_none(x))
            blocks[&#39;ExtractedData&#39;] = extracted_data
        return blocks

    def create_html(self, css_content: str | None = None, js_content: str | None = None, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Generates a complete HTML document from the processed text, incorporating optional CSS and JavaScript content.

        This method operates in several key steps:
        1. It first ensures that CSS and JavaScript content are set, either to the provided arguments or to default values.
        2. The method then retrieves the processed text with markers using the `get_marked_text` method.
        3. A nested function `replace_marker_with_html` is defined to handle the replacement of each marker within the text
        with the corresponding HTML content generated from the associated OrcaElement. This function:
        - Extracts the type, subtype, and unique ID from each marker.
        - Retrieves the corresponding OrcaElement from the _blocks DataFrame using the unique ID.
        - Calls the `to_html` method on the OrcaElement to generate its HTML representation.
        4. A regular expression is used to find all markers in the processed text, and the `replace_marker_with_html` function
        is applied to replace each marker with its HTML content.
        5. The full HTML document is assembled using the provided or default CSS and JavaScript, along with the body content
        that now includes the HTML representations of the OrcaElements.

        Parameters:
            css_content (str | None): Optional CSS content to include in the &lt;style&gt; tag of the HTML document. If None,
                                    a default CSS content is used.
            js_content (str | None): Optional JavaScript content to include in a &lt;script&gt; tag at the end of the document.
                                    If None, default JavaScript content is used.

        Returns:
            str: A string containing the complete HTML document.

        Raises:
            Exception: If an OrcaElement referenced by a marker cannot be found in the _blocks DataFrame, an exception is raised.

        Note:
            The HTML document includes a structure with a container div, a sidebar for a table of contents (TOC),
            a comment sidebar for additional annotations, and a content area where the main body content is placed.
            The TOC and comment sidebar are expected to be populated by the provided JavaScript.
        &#34;&#34;&#34;
        if css_content is None:
            # Get the directory of this file
            directory = os.path.dirname(__file__)
            # Construct the path to default.css
            css_file = os.path.join(directory, &#39;default.css&#39;)
            with open(css_file, &#34;r&#34;) as file:
                css_content = file.read()

        if js_content is None:
            # Get the directory of this file
            directory = os.path.dirname(__file__)
            # Construct the path to default.js
            js_file = os.path.join(directory, &#39;default.js&#39;)
            with open(js_file, &#34;r&#34;) as file:
                js_content = file.read()

        # Process the text to ensure all elements are captured
        processed_text = self.get_marked_text(show_progress=show_progress)

        body_content = &#39;&#39;.join(element[2].to_html()
                               for element in processed_text)

        # Construct the full HTML Document with CSS and JS if requested
        html_content = &#34;&lt;!DOCTYPE html&gt;\n&#34;
        html_content += &#34;&lt;html lang=\&#34;en\&#34;&gt;\n&lt;head&gt;\n&#34;
        html_content += &#34;    &lt;meta charset=\&#34;UTF-8\&#34;&gt;\n&#34;
        html_content += &#34;    &lt;meta name=\&#34;viewport\&#34; content=\&#34;width=device-width, initial-scale=1.0\&#34;&gt;\n&#34;
        html_content += &#34;    &lt;title&gt;ORCA&lt;/title&gt;\n&#34;

        if insert_css:
            html_content += &#34;    &lt;style&gt;\n        &#34; + \
                (css_content if css_content else &#34;&#34;) + &#34;\n    &lt;/style&gt;\n&#34;

        html_content += &#34;&lt;/head&gt;\n&lt;body&gt;\n&#34;
        html_content += &#34;    &lt;div class=\&#34;container\&#34;&gt;\n&#34;

        if insert_left_sidebar:
            html_content += &#34;        &lt;div class=\&#34;sidebar\&#34;&gt;\n&#34;
            html_content += &#34;            &lt;!-- Left sidebar content (TOC) --&gt;\n&#34;
            html_content += &#34;            &lt;div class=\&#34;toc\&#34;&gt;\n    &lt;!-- JavaScript will populate this area --&gt;\n&lt;/div&gt;&#34;
            html_content += &#34;        &lt;/div&gt;\n&#34;

        if insert_colorcomment_sidebar:
            html_content += &#34;        &lt;div class=\&#34;comment-sidebar\&#34;&gt;\n&#34;
            html_content += &#34;            &lt;!-- comment sidebar for color-comment sections --&gt;\n&#34;
            html_content += &#34;            &lt;!-- JavaScript will populate this area --&gt;\n        &lt;/div&gt;\n&#34;

        html_content += &#34;        &lt;div class=\&#34;content\&#34;&gt;\n            &#34; + \
            body_content + &#34;\n        &lt;/div&gt;\n&#34;
        html_content += &#34;    &lt;/div&gt;\n&#34;

        if insert_js:
            html_content += &#34;    &lt;script&gt;\n        &#34; + \
                (js_content if js_content else &#34;&#34;) + &#34;\n    &lt;/script&gt;\n&#34;

        html_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        return html_content

    def save_as_html(self, output_file_path: str, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress=False):
        &#34;&#34;&#34;
        Generates an HTML document from the OrcaFile instance with customizable options and saves it to the specified file path.

        This method performs the following actions:
        1. Calls the `create_html` method to generate the complete HTML content based on the processed text, optional CSS and JavaScript content, and conditional inclusion of the left sidebar (TOC) and the color-comment sidebar. The `create_html` method assembles the HTML document, incorporating the specified elements and transforms markers within the text into corresponding HTML elements.
        2. Opens the specified output file in write mode. If the file does not exist, it will be created; if it already exists, its content will be overwritten.
        3. Writes the generated HTML content to the file, effectively saving the entire content of the OrcaFile instance as an HTML document at the specified location.

        Parameters:
            output_file_path (str): The file path where the HTML document should be saved. This path includes the file name and extension, for example, &#39;output/document.html&#39;.
            insert_css (bool, optional): Specifies whether CSS content should be included in the HTML document. Defaults to True.
            insert_js (bool, optional): Specifies whether JavaScript content should be included in the HTML document. Defaults to True.
            insert_left_sidebar (bool, optional): Specifies whether a left sidebar for the Table of Contents (TOC) should be included in the HTML document. Defaults to True.
            insert_colorcomment_sidebar (bool, optional): Specifies whether a comment sidebar for additional annotations should be included in the HTML document. Defaults to True.

        Note:
            This method provides a flexible way to export the content of an OrcaFile instance to a standard HTML format, making it accessible for viewing in web browsers or for further processing with tools that accept HTML input. It allows for the customization of the exported HTML document through parameters that control the inclusion of CSS, JavaScript, and additional structural elements like sidebars.
        &#34;&#34;&#34;
        html_content = self.create_html(insert_css=insert_css, insert_js=insert_js,
                                        insert_left_sidebar=insert_left_sidebar, insert_colorcomment_sidebar=insert_colorcomment_sidebar, show_progress=show_progress)

        with open(output_file_path, &#39;w&#39;) as output_file:
            output_file.write(html_content)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="orcaparse.file.File.extract_data_errors_to_none"><code class="name flex">
<span>def <span class="ident">extract_data_errors_to_none</span></span>(<span>orca_element: <a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>) ‑> <a title="orcaparse.data.Data" href="data.html#orcaparse.data.Data">Data</a> | None</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to extract data from an OrcaElement, handling any errors by returning None.</p>
<p>This nested function is designed to be applied to each row of the DataFrame, specifically to each
OrcaElement in the 'Element' column. It encapsulates the error-handling logic, ensuring that any
exceptions raised during data extraction are caught and processed appropriately.</p>
<h2 id="parameters">Parameters</h2>
<p>orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.</p>
<h2 id="returns">Returns</h2>
<p>The extracted data from the OrcaElement in orcaparse.Data format, or None if an error occurred during the extraction process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def extract_data_errors_to_none(orca_element: Element) -&gt; Data | None:
    &#34;&#34;&#34;
    Attempts to extract data from an OrcaElement, handling any errors by returning None.

    This nested function is designed to be applied to each row of the DataFrame, specifically to each
    OrcaElement in the &#39;Element&#39; column. It encapsulates the error-handling logic, ensuring that any
    exceptions raised during data extraction are caught and processed appropriately.

    Parameters:
        orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.

    Returns:
        The extracted data from the OrcaElement in orcaparse.Data format, or None if an error occurred during the extraction process.
    &#34;&#34;&#34;
    try:
        # return Data(orca_element.data())
        return orca_element.data()
    except Exception as e:
        warnings.warn(
            f&#34;An unexpected error occurred while extracting data from {orca_element}: {e}, returning None instead of data.\n Raw context of the element is {orca_element.raw_data}&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.extract_raw_data_errors_to_none"><code class="name flex">
<span>def <span class="ident">extract_raw_data_errors_to_none</span></span>(<span>orca_element: <a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to extract data from an OrcaElement, handling any errors by returning None.</p>
<p>This nested function is designed to be applied to each row of the DataFrame, specifically to each
OrcaElement in the 'Element' column. It encapsulates the error-handling logic, ensuring that any
exceptions raised during data extraction are caught and processed appropriately.</p>
<h2 id="parameters">Parameters</h2>
<p>orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.</p>
<h2 id="returns">Returns</h2>
<p>The extracted data from the OrcaElement, or None if an error occurred during the extraction process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def extract_raw_data_errors_to_none(orca_element: Element) -&gt; str | None:
    &#34;&#34;&#34;
    Attempts to extract data from an OrcaElement, handling any errors by returning None.

    This nested function is designed to be applied to each row of the DataFrame, specifically to each
    OrcaElement in the &#39;Element&#39; column. It encapsulates the error-handling logic, ensuring that any
    exceptions raised during data extraction are caught and processed appropriately.

    Parameters:
        orca_element (OrcaElement): An instance of OrcaElement from which data is to be extracted.

    Returns:
        The extracted data from the OrcaElement, or None if an error occurred during the extraction process.
    &#34;&#34;&#34;
    try:
        # return Data(orca_element.data())
        return orca_element.raw_data
    except Exception as e:
        warnings.warn(
            f&#34;An unexpected error occurred while extracting raw_data from {orca_element}: {e}, returning None instead of data.\n That is really weird&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.file.File.create_html"><code class="name flex">
<span>def <span class="ident">create_html</span></span>(<span>self, css_content: str | None = None, js_content: str | None = None, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a complete HTML document from the processed text, incorporating optional CSS and JavaScript content.</p>
<p>This method operates in several key steps:
1. It first ensures that CSS and JavaScript content are set, either to the provided arguments or to default values.
2. The method then retrieves the processed text with markers using the <code>get_marked_text</code> method.
3. A nested function <code>replace_marker_with_html</code> is defined to handle the replacement of each marker within the text
with the corresponding HTML content generated from the associated OrcaElement. This function:
- Extracts the type, subtype, and unique ID from each marker.
- Retrieves the corresponding OrcaElement from the _blocks DataFrame using the unique ID.
- Calls the <code>to_html</code> method on the OrcaElement to generate its HTML representation.
4. A regular expression is used to find all markers in the processed text, and the <code>replace_marker_with_html</code> function
is applied to replace each marker with its HTML content.
5. The full HTML document is assembled using the provided or default CSS and JavaScript, along with the body content
that now includes the HTML representations of the OrcaElements.</p>
<h2 id="parameters">Parameters</h2>
<p>css_content (str | None): Optional CSS content to include in the <style> tag of the HTML document. If None,
a default CSS content is used.
js_content (str | None): Optional JavaScript content to include in a <script> tag at the end of the document.
If None, default JavaScript content is used.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string containing the complete HTML document.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If an OrcaElement referenced by a marker cannot be found in the _blocks DataFrame, an exception is raised.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The HTML document includes a structure with a container div, a sidebar for a table of contents (TOC),
a comment sidebar for additional annotations, and a content area where the main body content is placed.
The TOC and comment sidebar are expected to be populated by the provided JavaScript.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_html(self, css_content: str | None = None, js_content: str | None = None, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Generates a complete HTML document from the processed text, incorporating optional CSS and JavaScript content.

    This method operates in several key steps:
    1. It first ensures that CSS and JavaScript content are set, either to the provided arguments or to default values.
    2. The method then retrieves the processed text with markers using the `get_marked_text` method.
    3. A nested function `replace_marker_with_html` is defined to handle the replacement of each marker within the text
    with the corresponding HTML content generated from the associated OrcaElement. This function:
    - Extracts the type, subtype, and unique ID from each marker.
    - Retrieves the corresponding OrcaElement from the _blocks DataFrame using the unique ID.
    - Calls the `to_html` method on the OrcaElement to generate its HTML representation.
    4. A regular expression is used to find all markers in the processed text, and the `replace_marker_with_html` function
    is applied to replace each marker with its HTML content.
    5. The full HTML document is assembled using the provided or default CSS and JavaScript, along with the body content
    that now includes the HTML representations of the OrcaElements.

    Parameters:
        css_content (str | None): Optional CSS content to include in the &lt;style&gt; tag of the HTML document. If None,
                                a default CSS content is used.
        js_content (str | None): Optional JavaScript content to include in a &lt;script&gt; tag at the end of the document.
                                If None, default JavaScript content is used.

    Returns:
        str: A string containing the complete HTML document.

    Raises:
        Exception: If an OrcaElement referenced by a marker cannot be found in the _blocks DataFrame, an exception is raised.

    Note:
        The HTML document includes a structure with a container div, a sidebar for a table of contents (TOC),
        a comment sidebar for additional annotations, and a content area where the main body content is placed.
        The TOC and comment sidebar are expected to be populated by the provided JavaScript.
    &#34;&#34;&#34;
    if css_content is None:
        # Get the directory of this file
        directory = os.path.dirname(__file__)
        # Construct the path to default.css
        css_file = os.path.join(directory, &#39;default.css&#39;)
        with open(css_file, &#34;r&#34;) as file:
            css_content = file.read()

    if js_content is None:
        # Get the directory of this file
        directory = os.path.dirname(__file__)
        # Construct the path to default.js
        js_file = os.path.join(directory, &#39;default.js&#39;)
        with open(js_file, &#34;r&#34;) as file:
            js_content = file.read()

    # Process the text to ensure all elements are captured
    processed_text = self.get_marked_text(show_progress=show_progress)

    body_content = &#39;&#39;.join(element[2].to_html()
                           for element in processed_text)

    # Construct the full HTML Document with CSS and JS if requested
    html_content = &#34;&lt;!DOCTYPE html&gt;\n&#34;
    html_content += &#34;&lt;html lang=\&#34;en\&#34;&gt;\n&lt;head&gt;\n&#34;
    html_content += &#34;    &lt;meta charset=\&#34;UTF-8\&#34;&gt;\n&#34;
    html_content += &#34;    &lt;meta name=\&#34;viewport\&#34; content=\&#34;width=device-width, initial-scale=1.0\&#34;&gt;\n&#34;
    html_content += &#34;    &lt;title&gt;ORCA&lt;/title&gt;\n&#34;

    if insert_css:
        html_content += &#34;    &lt;style&gt;\n        &#34; + \
            (css_content if css_content else &#34;&#34;) + &#34;\n    &lt;/style&gt;\n&#34;

    html_content += &#34;&lt;/head&gt;\n&lt;body&gt;\n&#34;
    html_content += &#34;    &lt;div class=\&#34;container\&#34;&gt;\n&#34;

    if insert_left_sidebar:
        html_content += &#34;        &lt;div class=\&#34;sidebar\&#34;&gt;\n&#34;
        html_content += &#34;            &lt;!-- Left sidebar content (TOC) --&gt;\n&#34;
        html_content += &#34;            &lt;div class=\&#34;toc\&#34;&gt;\n    &lt;!-- JavaScript will populate this area --&gt;\n&lt;/div&gt;&#34;
        html_content += &#34;        &lt;/div&gt;\n&#34;

    if insert_colorcomment_sidebar:
        html_content += &#34;        &lt;div class=\&#34;comment-sidebar\&#34;&gt;\n&#34;
        html_content += &#34;            &lt;!-- comment sidebar for color-comment sections --&gt;\n&#34;
        html_content += &#34;            &lt;!-- JavaScript will populate this area --&gt;\n        &lt;/div&gt;\n&#34;

    html_content += &#34;        &lt;div class=\&#34;content\&#34;&gt;\n            &#34; + \
        body_content + &#34;\n        &lt;/div&gt;\n&#34;
    html_content += &#34;    &lt;/div&gt;\n&#34;

    if insert_js:
        html_content += &#34;    &lt;script&gt;\n        &#34; + \
            (js_content if js_content else &#34;&#34;) + &#34;\n    &lt;/script&gt;\n&#34;

    html_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

    return html_content</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.depth"><code class="name flex">
<span>def <span class="ident">depth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth(self) -&gt; int:
    return Element.max_depth(self.get_structure())</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.get_blocks"><code class="name flex">
<span>def <span class="ident">get_blocks</span></span>(<span>self, show_progress: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the DataFrame containing all processed blocks.</p>
<p>Ensures initialization has occurred before returning the blocks.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>DataFrame containing the processed blocks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blocks(self, show_progress: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Returns the DataFrame containing all processed blocks.

    Ensures initialization has occurred before returning the blocks.

    Returns:
        pd.DataFrame: DataFrame containing the processed blocks.
    &#34;&#34;&#34;
    self.initialize(show_progress=show_progress)
    return self._blocks</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self, extract_only_raw: bool = False, element_type: type[<a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>] | None = None, readable_name: str | None = None, raw_data_substring: Union[str, Iterable[str], ForwardRef(None)] = None, raw_data_not_substring: Union[str, Iterable[str], ForwardRef(None)] = None, show_progress: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves and extracts data or raw data strings from OrcaElement instances based on specified search criteria and extraction type.</p>
<p>This method first searches for OrcaElement instances based on the provided search criteria, which can include the element's type, readable name, or a substring of its raw data. After filtering the elements, it extracts either raw data strings or processed data from them, depending on the 'extract_raw' flag.</p>
<h2 id="parameters">Parameters</h2>
<p>extract_ony_raw (bool, optional): Determines if <code>ExtractedData</code> will be additionally created. If True, it will not. Raw data is stored in <code>RawData</code>. Defaults to False.
element_type (type[Element] | None, optional): The class type of the OrcaElements to filter by. Only elements that are instances of this type or derived from it will be included. Defaults to None, which skips this filter.
readable_name (str | None, optional): The exact name to match against the 'readable_name' attribute of OrcaElements. Only elements with a matching readable name are included. Defaults to None, which skips this filter.
raw_data_substring (str | Iterable[str] | None, optional): A substring to search for within the 'raw_data' attribute of OrcaElements. Only elements whose raw data contains this substring are included. Defaults to None, which skips this filter.
raw_data_not_substring (str | Iterable[str] | None, optional): A substring to search for within the 'raw_data' attribute of OrcaElements. The elements whose raw data contains this substring are not included. Defaults to None, which skips this filter.
show_progress (bool, optional): Determines if a progress bar is displayed when extracting data from elements. Defaults to False.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the extracted data or raw data strings from the filtered OrcaElements. The DataFrame includes an 'ExtractedData' column with the extracted information. If no elements match the search criteria, an empty DataFrame is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self, extract_only_raw: bool = False, element_type: type[Element] | None = None, readable_name: str | None = None, raw_data_substring: str | Iterable[str] | None = None, raw_data_not_substring: str | Iterable[str] | None = None, show_progress: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Retrieves and extracts data or raw data strings from OrcaElement instances based on specified search criteria and extraction type.

    This method first searches for OrcaElement instances based on the provided search criteria, which can include the element&#39;s type, readable name, or a substring of its raw data. After filtering the elements, it extracts either raw data strings or processed data from them, depending on the &#39;extract_raw&#39; flag.

    Parameters:
        extract_ony_raw (bool, optional): Determines if `ExtractedData` will be additionally created. If True, it will not. Raw data is stored in `RawData`. Defaults to False.
        element_type (type[Element] | None, optional): The class type of the OrcaElements to filter by. Only elements that are instances of this type or derived from it will be included. Defaults to None, which skips this filter.
        readable_name (str | None, optional): The exact name to match against the &#39;readable_name&#39; attribute of OrcaElements. Only elements with a matching readable name are included. Defaults to None, which skips this filter.
        raw_data_substring (str | Iterable[str] | None, optional): A substring to search for within the &#39;raw_data&#39; attribute of OrcaElements. Only elements whose raw data contains this substring are included. Defaults to None, which skips this filter.
        raw_data_not_substring (str | Iterable[str] | None, optional): A substring to search for within the &#39;raw_data&#39; attribute of OrcaElements. The elements whose raw data contains this substring are not included. Defaults to None, which skips this filter.
        show_progress (bool, optional): Determines if a progress bar is displayed when extracting data from elements. Defaults to False.

    Returns:
        pd.DataFrame: A DataFrame containing the extracted data or raw data strings from the filtered OrcaElements. The DataFrame includes an &#39;ExtractedData&#39; column with the extracted information. If no elements match the search criteria, an empty DataFrame is returned.
    &#34;&#34;&#34;
    blocks = self.search_elements(element_type=element_type,
                                  readable_name=readable_name,
                                  raw_data_substring=raw_data_substring,
                                  raw_data_not_substring=raw_data_not_substring,
                                  show_progress=show_progress)
    if not extract_only_raw:
        # Implement the logic to extract processed data from blocks
        extracted_data = blocks[&#39;Element&#39;].apply(
            lambda x: self.extract_data_errors_to_none(x))
        blocks[&#39;ExtractedData&#39;] = extracted_data
    return blocks</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.get_marked_text"><code class="name flex">
<span>def <span class="ident">get_marked_text</span></span>(<span>self, show_progress: bool = False) ‑> list[tuple[tuple[int, int], tuple[int, int], <a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the text with markers after processing patterns.</p>
<p>Ensures initialization has occurred before returning the marked text.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The marked text.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_marked_text(self, show_progress: bool = False) -&gt; list[tuple[tuple[int, int], tuple[int, int], Element]]:
    &#34;&#34;&#34;
    Returns the text with markers after processing patterns.

    Ensures initialization has occurred before returning the marked text.

    Returns:
        str: The marked text.
    &#34;&#34;&#34;
    self.initialize(show_progress=show_progress)
    return self._marked_text</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.get_structure"><code class="name flex">
<span>def <span class="ident">get_structure</span></span>(<span>self) ‑> dict[typing_extensions.Self, tuple | None]</span>
</code></dt>
<dd>
<div class="desc"><p>Structure in a form of nested dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_structure(self) -&gt; dict[Self, tuple | None]:
    &#39;&#39;&#39;
        Structure in a form of nested dict
    &#39;&#39;&#39;
    blocks = self.get_blocks()
    return [self, list(blocks[&#39;Element&#39;].apply(lambda x: x.get_structure()))]</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, show_progress: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the instance by processing patterns if not already done.</p>
<p>This method sets <code>self.initialized</code> to True after processing to avoid redundant initializations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, show_progress: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Initializes the instance by processing patterns if not already done.

    This method sets `self.initialized` to True after processing to avoid redundant initializations.
    &#34;&#34;&#34;
    if not self.initialized:
        self.process_patterns(show_progress=show_progress)
        self.initialized = True</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.process_patterns"><code class="name flex">
<span>def <span class="ident">process_patterns</span></span>(<span>self, show_progress=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the regex patterns defined in the OrcaFile's regex settings to identify, extract, and
instantiate OrcaElements from the file's text. It updates the internal _blocks DataFrame with the
extracted elements and their metadata, and replaces identified patterns in the text with unique markers.</p>
<p>This method performs several steps:
1. Resets the _blocks DataFrame to ensure it's ready for new data.
2. Iterates over each regex pattern defined in the file's regex settings.
3. Uses each pattern to search through the original text, identifying matches.
4. For each match, extracts relevant data and uses it to instantiate the corresponding OrcaElement subclass.
5. Generates a unique ID for each extracted element and uses it to replace the original text with a marker.
6. Updates the _blocks DataFrame with new rows containing the element data, type, subtype, and its position within the text.
7. Replaces identified patterns in the text with markers that include the type, subtype, and unique ID of the extracted elements.</p>
<p>Upon completion, the text is fully processed, with all elements identified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_patterns(self, show_progress=False):
    &#34;&#34;&#34;
    Processes the regex patterns defined in the OrcaFile&#39;s regex settings to identify, extract, and
    instantiate OrcaElements from the file&#39;s text. It updates the internal _blocks DataFrame with the
    extracted elements and their metadata, and replaces identified patterns in the text with unique markers.

    This method performs several steps:
    1. Resets the _blocks DataFrame to ensure it&#39;s ready for new data.
    2. Iterates over each regex pattern defined in the file&#39;s regex settings.
    3. Uses each pattern to search through the original text, identifying matches.
    4. For each match, extracts relevant data and uses it to instantiate the corresponding OrcaElement subclass.
    5. Generates a unique ID for each extracted element and uses it to replace the original text with a marker.
    6. Updates the _blocks DataFrame with new rows containing the element data, type, subtype, and its position within the text.
    7. Replaces identified patterns in the text with markers that include the type, subtype, and unique ID of the extracted elements.

    Upon completion, the text is fully processed, with all elements identified.
    &#34;&#34;&#34;
    self._blocks = pd.DataFrame(
        columns=[&#39;Type&#39;, &#39;Subtype&#39;, &#39;Element&#39;, &#39;CharPosition&#39;, &#39;LinePosition&#39;])
    self._marked_text: list[tuple[tuple[int, int], tuple[int, int], str | Element]] = [
        ((0, len(self.original_text)),
         (1, self.original_text.count(&#39;\n&#39;) + 1), self.original_text)
    ]

    self.initialized = True

    for regex in self.regex_settings.to_list():
        self._marked_text, new_blocks = regex.apply(
            self._marked_text, mode=self.mode, show_progress=show_progress)
        new_blocks_df = pd.DataFrame.from_dict(new_blocks, orient=&#34;index&#34;)
        new_blocks_df[&#39;Type&#39;] = regex.p_type
        new_blocks_df[&#39;Subtype&#39;] = regex.p_subtype
        self._blocks = pd.concat([self._blocks, new_blocks_df])

    unknown_blocks = {}

    for i, (char_position, line_position, block) in enumerate(self._marked_text):
        if isinstance(block, str):
            unknown_block = BlockUnknown(
                block, char_position=char_position, line_position=line_position)
            self._marked_text[i] = (
                char_position, line_position, unknown_block)
            unknown_blocks[hash(unknown_block)] = {
                &#39;Element&#39;: unknown_block, &#39;CharPosition&#39;: char_position, &#39;LinePosition&#39;: line_position}

    unknown_blocks_df = pd.DataFrame.from_dict(
        unknown_blocks, orient=&#34;index&#34;)
    unknown_blocks_df[&#39;Type&#39;] = &#39;Block&#39;
    unknown_blocks_df[&#39;Subtype&#39;] = &#39;BlockUnknown&#39;

    self._blocks = pd.concat([self._blocks, unknown_blocks_df])</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.save_as_html"><code class="name flex">
<span>def <span class="ident">save_as_html</span></span>(<span>self, output_file_path: str, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an HTML document from the OrcaFile instance with customizable options and saves it to the specified file path.</p>
<p>This method performs the following actions:
1. Calls the <code>create_html</code> method to generate the complete HTML content based on the processed text, optional CSS and JavaScript content, and conditional inclusion of the left sidebar (TOC) and the color-comment sidebar. The <code>create_html</code> method assembles the HTML document, incorporating the specified elements and transforms markers within the text into corresponding HTML elements.
2. Opens the specified output file in write mode. If the file does not exist, it will be created; if it already exists, its content will be overwritten.
3. Writes the generated HTML content to the file, effectively saving the entire content of the OrcaFile instance as an HTML document at the specified location.</p>
<h2 id="parameters">Parameters</h2>
<p>output_file_path (str): The file path where the HTML document should be saved. This path includes the file name and extension, for example, 'output/document.html'.
insert_css (bool, optional): Specifies whether CSS content should be included in the HTML document. Defaults to True.
insert_js (bool, optional): Specifies whether JavaScript content should be included in the HTML document. Defaults to True.
insert_left_sidebar (bool, optional): Specifies whether a left sidebar for the Table of Contents (TOC) should be included in the HTML document. Defaults to True.
insert_colorcomment_sidebar (bool, optional): Specifies whether a comment sidebar for additional annotations should be included in the HTML document. Defaults to True.</p>
<h2 id="note">Note</h2>
<p>This method provides a flexible way to export the content of an OrcaFile instance to a standard HTML format, making it accessible for viewing in web browsers or for further processing with tools that accept HTML input. It allows for the customization of the exported HTML document through parameters that control the inclusion of CSS, JavaScript, and additional structural elements like sidebars.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_html(self, output_file_path: str, insert_css: bool = True, insert_js: bool = True, insert_left_sidebar: bool = True, insert_colorcomment_sidebar: bool = True, show_progress=False):
    &#34;&#34;&#34;
    Generates an HTML document from the OrcaFile instance with customizable options and saves it to the specified file path.

    This method performs the following actions:
    1. Calls the `create_html` method to generate the complete HTML content based on the processed text, optional CSS and JavaScript content, and conditional inclusion of the left sidebar (TOC) and the color-comment sidebar. The `create_html` method assembles the HTML document, incorporating the specified elements and transforms markers within the text into corresponding HTML elements.
    2. Opens the specified output file in write mode. If the file does not exist, it will be created; if it already exists, its content will be overwritten.
    3. Writes the generated HTML content to the file, effectively saving the entire content of the OrcaFile instance as an HTML document at the specified location.

    Parameters:
        output_file_path (str): The file path where the HTML document should be saved. This path includes the file name and extension, for example, &#39;output/document.html&#39;.
        insert_css (bool, optional): Specifies whether CSS content should be included in the HTML document. Defaults to True.
        insert_js (bool, optional): Specifies whether JavaScript content should be included in the HTML document. Defaults to True.
        insert_left_sidebar (bool, optional): Specifies whether a left sidebar for the Table of Contents (TOC) should be included in the HTML document. Defaults to True.
        insert_colorcomment_sidebar (bool, optional): Specifies whether a comment sidebar for additional annotations should be included in the HTML document. Defaults to True.

    Note:
        This method provides a flexible way to export the content of an OrcaFile instance to a standard HTML format, making it accessible for viewing in web browsers or for further processing with tools that accept HTML input. It allows for the customization of the exported HTML document through parameters that control the inclusion of CSS, JavaScript, and additional structural elements like sidebars.
    &#34;&#34;&#34;
    html_content = self.create_html(insert_css=insert_css, insert_js=insert_js,
                                    insert_left_sidebar=insert_left_sidebar, insert_colorcomment_sidebar=insert_colorcomment_sidebar, show_progress=show_progress)

    with open(output_file_path, &#39;w&#39;) as output_file:
        output_file.write(html_content)</code></pre>
</details>
</dd>
<dt id="orcaparse.file.File.search_elements"><code class="name flex">
<span>def <span class="ident">search_elements</span></span>(<span>self, element_type: type[<a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>] | None = None, readable_name: str | None = None, raw_data_substring: Union[str, Iterable[str], ForwardRef(None)] = None, raw_data_not_substring: Union[str, Iterable[str], ForwardRef(None)] = None, show_progress: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for OrcaElement instances based on various criteria.</p>
<h2 id="parameters">Parameters</h2>
<p>element_type (type[Element], optional): The class type of the OrcaElement to search for.
readable_name (str, optional): The exact term to search for in the readable_name attribute.
raw_data_substring (str, Iterable[str], optional): The substring to search for within the raw_data attribute.
raw_data_not_substring (str, Iterable[str], optional): The substring to search the absence of within the raw_data attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the filtered OrcaElements based on the provided criteria.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_elements(self, element_type: type[Element] | None = None, readable_name: str | None = None, raw_data_substring: str | Iterable[str] | None = None, raw_data_not_substring: str | Iterable[str] | None = None, show_progress: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Searches for OrcaElement instances based on various criteria.

    Parameters:
        element_type (type[Element], optional): The class type of the OrcaElement to search for.
        readable_name (str, optional): The exact term to search for in the readable_name attribute.
        raw_data_substring (str, Iterable[str], optional): The substring to search for within the raw_data attribute.
        raw_data_not_substring (str, Iterable[str], optional): The substring to search the absence of within the raw_data attribute.

    Returns:
        pd.DataFrame: A DataFrame containing the filtered OrcaElements based on the provided criteria.
    &#34;&#34;&#34;
    self.initialize(show_progress=show_progress)
    blocks_copy = self._blocks.copy()
    blocks_copy[&#39;ReadableName&#39;] = blocks_copy[&#39;Element&#39;].apply(
        lambda x: x.readable_name())
    blocks_copy[&#39;RawData&#39;] = blocks_copy[&#39;Element&#39;].apply(
        lambda x: self.extract_raw_data_errors_to_none(x))

    if element_type is not None and len(blocks_copy) &gt; 0:
        blocks_copy = blocks_copy[blocks_copy[&#39;Element&#39;].apply(
            lambda x: isinstance(x, element_type))]

    if readable_name is not None and len(blocks_copy) &gt; 0:

        blocks_copy = blocks_copy[blocks_copy[&#39;ReadableName&#39;]
                                  == readable_name]

    if raw_data_substring is not None and len(blocks_copy) &gt; 0:
        def contains_all_substrings(x_raw_data, substrings):
            # If substrings is a string, convert it to a list for uniformity
            if isinstance(substrings, str):
                substrings = [substrings]

            # Check if all elements in substrings are in x_raw_data
            return all(substring in x_raw_data for substring in substrings)

        # Filter rows where all substrings are present in the RawData
        matches = blocks_copy[&#39;RawData&#39;].apply(
            lambda x: contains_all_substrings(x, raw_data_substring))
        blocks_copy = blocks_copy[matches]

    if raw_data_not_substring is not None and len(blocks_copy) &gt; 0:
        def contains_no_substrings(x_raw_data, substrings):
            # If substrings is a string, convert it to a list for uniformity
            if isinstance(substrings, str):
                substrings = [substrings]

            # Check if all elements in substrings are not in x_raw_data
            return all(substring not in x_raw_data for substring in substrings)

        # Filter rows where all substrings are not present in the RawData
        matches = blocks_copy[&#39;RawData&#39;].apply(
            lambda x: contains_no_substrings(x, raw_data_not_substring))
        blocks_copy = blocks_copy[matches]

    return blocks_copy</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orcaparse" href="index.html">orcaparse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orcaparse.file.File" href="#orcaparse.file.File">File</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.file.File.create_html" href="#orcaparse.file.File.create_html">create_html</a></code></li>
<li><code><a title="orcaparse.file.File.depth" href="#orcaparse.file.File.depth">depth</a></code></li>
<li><code><a title="orcaparse.file.File.extract_data_errors_to_none" href="#orcaparse.file.File.extract_data_errors_to_none">extract_data_errors_to_none</a></code></li>
<li><code><a title="orcaparse.file.File.extract_raw_data_errors_to_none" href="#orcaparse.file.File.extract_raw_data_errors_to_none">extract_raw_data_errors_to_none</a></code></li>
<li><code><a title="orcaparse.file.File.get_blocks" href="#orcaparse.file.File.get_blocks">get_blocks</a></code></li>
<li><code><a title="orcaparse.file.File.get_data" href="#orcaparse.file.File.get_data">get_data</a></code></li>
<li><code><a title="orcaparse.file.File.get_marked_text" href="#orcaparse.file.File.get_marked_text">get_marked_text</a></code></li>
<li><code><a title="orcaparse.file.File.get_structure" href="#orcaparse.file.File.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.file.File.initialize" href="#orcaparse.file.File.initialize">initialize</a></code></li>
<li><code><a title="orcaparse.file.File.process_patterns" href="#orcaparse.file.File.process_patterns">process_patterns</a></code></li>
<li><code><a title="orcaparse.file.File.save_as_html" href="#orcaparse.file.File.save_as_html">save_as_html</a></code></li>
<li><code><a title="orcaparse.file.File.search_elements" href="#orcaparse.file.File.search_elements">search_elements</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>