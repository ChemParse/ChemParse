<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orcaparse.regex_request API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orcaparse.regex_request</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import time
import warnings
from typing import Pattern, Union

from tqdm import tqdm

from .elements import Block, Element, Spacer
from .gpaw_elements import AvailableBlocksGpaw
from .orca_elements import AvailableBlocksOrca


class RegexRequest:
    def __init__(self, p_type: str, p_subtype: str, pattern: str, flags: list[str], comment: str = &#39;&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initializes a new RegexRequest object.

        Args:
            p_type (str): The type of the regex request, e.g., &#39;Block&#39;.
            p_subtype (str): The subtype of the regex request, providing more specific identification.
            pattern (str): The regex pattern.
            flags (list[str]): A list of strings representing regex flags, e.g., [&#39;MULTILINE&#39;, &#39;IGNORECASE&#39;].
            comment (str): An optional comment describing the regex request.
        &#34;&#34;&#34;
        self.p_type = p_type
        self.p_subtype = p_subtype
        self.pattern = pattern
        self.comment = comment
        self.flags = self._compile_flags(flags)

    def _compile_flags(self, flag_names: list[str]) -&gt; int:
        &#34;&#34;&#34;
        Compiles a list of flag names into a single integer representing the combined flags.

        Args:
            flag_names (list[str]): A list of flag names as strings.

        Returns:
            int: The combined flags as a single integer.

        Raises:
            ValueError: If an invalid flag name is provided.
        &#34;&#34;&#34;
        compiled_flags = 0
        valid_flags = {
            &#34;IGNORECASE&#34;: re.IGNORECASE,
            &#34;MULTILINE&#34;: re.MULTILINE,
            &#34;DOTALL&#34;: re.DOTALL,
            &#34;UNICODE&#34;: re.UNICODE,
            &#34;VERBOSE&#34;: re.VERBOSE
        }
        for flag_name in flag_names:
            flag = valid_flags.get(flag_name.upper())
            if flag is not None:
                compiled_flags |= flag
            else:
                raise ValueError(f&#34;Invalid flag: {flag_name}&#34;)
        return compiled_flags

    def _decompile_flags(self) -&gt; list[str]:
        &#34;&#34;&#34;
        Decompile the integer flags into a list of their string representations.

        Returns:
            list[str]: A list of flag names as strings.
        &#34;&#34;&#34;
        valid_flags = {
            &#34;IGNORECASE&#34;: re.IGNORECASE,
            &#34;MULTILINE&#34;: re.MULTILINE,
            &#34;DOTALL&#34;: re.DOTALL,
            &#34;UNICODE&#34;: re.UNICODE,
            &#34;VERBOSE&#34;: re.VERBOSE
        }
        flag_names = [flag_str for flag_str,
                      flag_val in valid_flags.items() if self.flags &amp; flag_val]
        return flag_names

    def validate_configuration(self) -&gt; None:
        &#34;&#34;&#34;
        Validates the configuration of the RegexRequest. Currently, this method does not perform any checks.
        &#34;&#34;&#34;
        pass

    def to_dict(self) -&gt; dict[str, Union[str, list[str]]]:
        &#34;&#34;&#34;
        Converts the RegexRequest instance to a dictionary, including string representations for flags.

        Returns:
            dict[str, Union[str, list[str]]]: A dictionary representation of the RegexRequest.
        &#34;&#34;&#34;
        return {
            &#34;p_type&#34;: self.p_type,
            &#34;p_subtype&#34;: self.p_subtype,
            &#34;pattern&#34;: self.pattern,
            &#34;flags&#34;: self._decompile_flags(),
            &#34;comment&#34;: self.comment
        }

    def compile(self) -&gt; Pattern:
        &#34;&#34;&#34;
        Compiles the regex pattern with the specified flags and returns a compiled regex pattern object.

        This method allows the user to utilize the compiled pattern object for various regex operations such as `findall`, `search`, `match`, etc.

        Returns:
            Pattern: A compiled regex pattern object.
        &#34;&#34;&#34;
        return re.compile(self.pattern, self.flags)

    def apply(self, marked_text: list[tuple[tuple[int, int], tuple[int, int], Element]] | str, mode: str = &#39;ORCA&#39;, show_progress: bool = False) -&gt; tuple[str, dict[str, dict]]:
        &#34;&#34;&#34;
        Apply the regular expression pattern to the marked text and extract elements.

        Args:
            marked_text (list[tuple[tuple[int, int], tuple[int, int], Element]] | str): The marked text to apply the pattern to.
                It can be either a list of tuples containing the position, line numbers, and element, or a string.
            mode (str): The mode to use for element extraction, either &#39;ORCA&#39; or &#39;GPAW&#39;.
            show_progress (bool): A flag indicating whether to show a progress bar during the extraction process.

        Returns:
            tuple[str, dict[str, dict]]: A tuple containing the modified marked text and a dictionary
                of extracted elements with their positions.
        &#34;&#34;&#34;
        if mode == &#39;ORCA&#39;:
            AB = AvailableBlocksOrca
        elif mode == &#39;GPAW&#39;:
            AB = AvailableBlocksGpaw
        else:
            raise ValueError(f&#34;Mode &#39;{mode}&#39; is not recognized.&#34;)

        if isinstance(marked_text, str):
            marked_text = [
                ((0, len(marked_text)), (1, marked_text.count(&#39;\n&#39;) + 1), marked_text)]

        compiled_pattern = self.compile()
        elements_dict = {}

        total_chars = marked_text[-1][0][1]

        # Added prefix_text parameter
        def with_progress_bar(show_progress: bool, refresh_interval: float = 2, prefix_text: str = f&#34;Processing {self.p_subtype}:&#34;):
            def decorator(func):
                if not show_progress:
                    return func

                def wrapper(*args, **kwargs):
                    nonlocal total_chars  # Assuming total_chars is defined in the outer scope
                    # Set prefix text using desc parameter
                    pbar = tqdm(total=total_chars, desc=prefix_text)

                    last_update_time = time.time()

                    # Added optional block_position
                    def update_progress(current_char_pos, block_position=None):
                        nonlocal last_update_time
                        current_time = time.time()
                        if current_time - last_update_time &gt;= refresh_interval:
                            pbar.n = current_char_pos
                            if block_position:  # Update postfix text if provided
                                pbar.set_postfix_str(
                                    f&#39;Current block position: {block_position}&#39;)
                            pbar.refresh()
                            last_update_time = current_time

                    kwargs[&#39;progress_callback&#39;] = update_progress
                    result = func(*args, **kwargs)
                    pbar.n = total_chars  # Ensure the progress bar completes if not already
                    pbar.refresh()
                    pbar.close()
                    return result

                return wrapper
            return decorator

        @with_progress_bar(show_progress=show_progress, refresh_interval=2, prefix_text=f&#34;Processing {self.p_subtype}&#34;)
        def process_marked_text(marked_text, elements_dict, progress_callback=None):
            def break_block(block, elements_dict, progress_callback=None):
                char_pos, line_pos, text = block
                result = []
                last_match_end = 0  # Tracks the end of the last match

                def convert_to_tuples(text_list, progress_callback=None):
                    result = []
                    # Start from the first character
                    current_char_pos = char_pos[0]
                    current_line_pos = line_pos[0]  # Start from the first line

                    for item in text_list:
                        if item is None or len(item) == 0:
                            continue
                        char_start = current_char_pos
                        # -1 because end is inclusive
                        char_end = current_char_pos + len(item) - 1

                        # Count the lines in the current segment
                        lines_in_item = item.count(&#39;\n&#39;)
                        line_start = current_line_pos
                        line_end = current_line_pos + lines_in_item

                        # Update for the next iteration
                        current_char_pos = char_end + 1
                        current_line_pos = line_end + 1 if lines_in_item &gt; 0 else current_line_pos

                        result.append(
                            ((char_start, char_end), (line_start, line_end), item))

                    return result

                def convert_to_element(item, elements_dict, compiled_pattern, progress_callback=None):
                    if progress_callback:
                        progress_callback(item[0][1], block_position=item[0])
                    if compiled_pattern.fullmatch(item[2]):
                        char_pos, line_pos, extracted_text = item

                        if self.p_type == &#34;Block&#34;:
                            if self.p_subtype in AB.blocks:
                                # Create an instance of the class with position parameter
                                element_instance = AB.blocks[self.p_subtype](
                                    extracted_text, char_position=char_pos, line_position=line_pos)
                            else:
                                warnings.warn(
                                    (f&#34;Subtype `{self.p_subtype}`&#34;
                                        f&#34; not recognized. Falling back to Block.&#34;)
                                )
                                element_instance = Block(
                                    extracted_text, char_position=char_pos, line_position=line_pos)
                        elif self.p_type == &#34;Spacer&#34;:
                            element_instance = Spacer(
                                extracted_text, char_position=char_pos, line_position=line_pos)

                        elements_dict[hash(element_instance)] = {
                            &#39;Element&#39;: element_instance, &#39;CharPosition&#39;: char_pos, &#39;LinePosition&#39;: line_pos}

                        return (char_pos, line_pos, element_instance)

                    return item

                def split_by_full_matches(text, compiled_pattern):
                    segments = []
                    start = 0

                    for match in compiled_pattern.finditer(text):
                        # Add the text leading up to the match (if any)
                        if match.start() &gt; start:
                            segments.append(text[start:match.start()])

                        # Add the matched text
                        segments.append(match.group())

                        # Update the start position for the next iteration
                        start = match.end()

                    # Add any remaining text after the last match
                    if start &lt; len(text):
                        segments.append(text[start:])

                    return segments

                # split by full matches instead of re split to allow the internal groups in regex
                text_list = split_by_full_matches(text, compiled_pattern)

                text_list = convert_to_tuples(
                    text_list, progress_callback=progress_callback)

                text_list = [convert_to_element(
                    item, elements_dict, compiled_pattern, progress_callback=progress_callback) for item in text_list]

                return text_list, elements_dict

            i = 0
            while i &lt; len(marked_text):
                # Assuming the structure is [(tuple, tuple, str/Element)]
                if isinstance(marked_text[i][2], str):
                    result, elements_dict = break_block(
                        marked_text[i], elements_dict, progress_callback=progress_callback)
                    if result:
                        # Remove the original item
                        del marked_text[i]

                        # Insert the new items from &#39;result&#39; at position &#39;i&#39;
                        # for item in reversed(result):
                        #     marked_text.insert(i, item)
                        marked_text[i:i] = result

                        # Increment &#39;i&#39; by the number of new items inserted
                        i += len(result)
                    else:
                        # No blocks found, move to the next item
                        i += 1
                else:
                    # The item is not a string, move to the next item
                    i += 1

            return marked_text, elements_dict

        marked_text, elements_dict = process_marked_text(
            marked_text=marked_text, elements_dict=elements_dict)

        return marked_text, elements_dict

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the RegexRequest, which is always 1 for a single request.

        Returns:
            int: The length of the RegexRequest.
        &#34;&#34;&#34;
        return 1

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Provides a string representation of the RegexRequest.

        Returns:
            str: A string representation of the RegexRequest.
        &#34;&#34;&#34;
        pattern = self.pattern if len(
            self.pattern) &lt; 25 else self.pattern[:25] + &#39;...&#39;
        comment = self.comment if len(
            self.comment) &lt; 25 else self.comment[:25] + &#39;...&#39;
        return f&#34;RegexRequest(p_type={self.p_type}, p_subtype={self.p_subtype}, pattern={pattern}, flags={self.flags}, comment={comment})&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orcaparse.regex_request.RegexRequest"><code class="flex name class">
<span>class <span class="ident">RegexRequest</span></span>
<span>(</span><span>p_type: str, p_subtype: str, pattern: str, flags: list[str], comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a new RegexRequest object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of the regex request, e.g., 'Block'.</dd>
<dt><strong><code>p_subtype</code></strong> :&ensp;<code>str</code></dt>
<dd>The subtype of the regex request, providing more specific identification.</dd>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>The regex pattern.</dd>
<dt><strong><code>flags</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>A list of strings representing regex flags, e.g., ['MULTILINE', 'IGNORECASE'].</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional comment describing the regex request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexRequest:
    def __init__(self, p_type: str, p_subtype: str, pattern: str, flags: list[str], comment: str = &#39;&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initializes a new RegexRequest object.

        Args:
            p_type (str): The type of the regex request, e.g., &#39;Block&#39;.
            p_subtype (str): The subtype of the regex request, providing more specific identification.
            pattern (str): The regex pattern.
            flags (list[str]): A list of strings representing regex flags, e.g., [&#39;MULTILINE&#39;, &#39;IGNORECASE&#39;].
            comment (str): An optional comment describing the regex request.
        &#34;&#34;&#34;
        self.p_type = p_type
        self.p_subtype = p_subtype
        self.pattern = pattern
        self.comment = comment
        self.flags = self._compile_flags(flags)

    def _compile_flags(self, flag_names: list[str]) -&gt; int:
        &#34;&#34;&#34;
        Compiles a list of flag names into a single integer representing the combined flags.

        Args:
            flag_names (list[str]): A list of flag names as strings.

        Returns:
            int: The combined flags as a single integer.

        Raises:
            ValueError: If an invalid flag name is provided.
        &#34;&#34;&#34;
        compiled_flags = 0
        valid_flags = {
            &#34;IGNORECASE&#34;: re.IGNORECASE,
            &#34;MULTILINE&#34;: re.MULTILINE,
            &#34;DOTALL&#34;: re.DOTALL,
            &#34;UNICODE&#34;: re.UNICODE,
            &#34;VERBOSE&#34;: re.VERBOSE
        }
        for flag_name in flag_names:
            flag = valid_flags.get(flag_name.upper())
            if flag is not None:
                compiled_flags |= flag
            else:
                raise ValueError(f&#34;Invalid flag: {flag_name}&#34;)
        return compiled_flags

    def _decompile_flags(self) -&gt; list[str]:
        &#34;&#34;&#34;
        Decompile the integer flags into a list of their string representations.

        Returns:
            list[str]: A list of flag names as strings.
        &#34;&#34;&#34;
        valid_flags = {
            &#34;IGNORECASE&#34;: re.IGNORECASE,
            &#34;MULTILINE&#34;: re.MULTILINE,
            &#34;DOTALL&#34;: re.DOTALL,
            &#34;UNICODE&#34;: re.UNICODE,
            &#34;VERBOSE&#34;: re.VERBOSE
        }
        flag_names = [flag_str for flag_str,
                      flag_val in valid_flags.items() if self.flags &amp; flag_val]
        return flag_names

    def validate_configuration(self) -&gt; None:
        &#34;&#34;&#34;
        Validates the configuration of the RegexRequest. Currently, this method does not perform any checks.
        &#34;&#34;&#34;
        pass

    def to_dict(self) -&gt; dict[str, Union[str, list[str]]]:
        &#34;&#34;&#34;
        Converts the RegexRequest instance to a dictionary, including string representations for flags.

        Returns:
            dict[str, Union[str, list[str]]]: A dictionary representation of the RegexRequest.
        &#34;&#34;&#34;
        return {
            &#34;p_type&#34;: self.p_type,
            &#34;p_subtype&#34;: self.p_subtype,
            &#34;pattern&#34;: self.pattern,
            &#34;flags&#34;: self._decompile_flags(),
            &#34;comment&#34;: self.comment
        }

    def compile(self) -&gt; Pattern:
        &#34;&#34;&#34;
        Compiles the regex pattern with the specified flags and returns a compiled regex pattern object.

        This method allows the user to utilize the compiled pattern object for various regex operations such as `findall`, `search`, `match`, etc.

        Returns:
            Pattern: A compiled regex pattern object.
        &#34;&#34;&#34;
        return re.compile(self.pattern, self.flags)

    def apply(self, marked_text: list[tuple[tuple[int, int], tuple[int, int], Element]] | str, mode: str = &#39;ORCA&#39;, show_progress: bool = False) -&gt; tuple[str, dict[str, dict]]:
        &#34;&#34;&#34;
        Apply the regular expression pattern to the marked text and extract elements.

        Args:
            marked_text (list[tuple[tuple[int, int], tuple[int, int], Element]] | str): The marked text to apply the pattern to.
                It can be either a list of tuples containing the position, line numbers, and element, or a string.
            mode (str): The mode to use for element extraction, either &#39;ORCA&#39; or &#39;GPAW&#39;.
            show_progress (bool): A flag indicating whether to show a progress bar during the extraction process.

        Returns:
            tuple[str, dict[str, dict]]: A tuple containing the modified marked text and a dictionary
                of extracted elements with their positions.
        &#34;&#34;&#34;
        if mode == &#39;ORCA&#39;:
            AB = AvailableBlocksOrca
        elif mode == &#39;GPAW&#39;:
            AB = AvailableBlocksGpaw
        else:
            raise ValueError(f&#34;Mode &#39;{mode}&#39; is not recognized.&#34;)

        if isinstance(marked_text, str):
            marked_text = [
                ((0, len(marked_text)), (1, marked_text.count(&#39;\n&#39;) + 1), marked_text)]

        compiled_pattern = self.compile()
        elements_dict = {}

        total_chars = marked_text[-1][0][1]

        # Added prefix_text parameter
        def with_progress_bar(show_progress: bool, refresh_interval: float = 2, prefix_text: str = f&#34;Processing {self.p_subtype}:&#34;):
            def decorator(func):
                if not show_progress:
                    return func

                def wrapper(*args, **kwargs):
                    nonlocal total_chars  # Assuming total_chars is defined in the outer scope
                    # Set prefix text using desc parameter
                    pbar = tqdm(total=total_chars, desc=prefix_text)

                    last_update_time = time.time()

                    # Added optional block_position
                    def update_progress(current_char_pos, block_position=None):
                        nonlocal last_update_time
                        current_time = time.time()
                        if current_time - last_update_time &gt;= refresh_interval:
                            pbar.n = current_char_pos
                            if block_position:  # Update postfix text if provided
                                pbar.set_postfix_str(
                                    f&#39;Current block position: {block_position}&#39;)
                            pbar.refresh()
                            last_update_time = current_time

                    kwargs[&#39;progress_callback&#39;] = update_progress
                    result = func(*args, **kwargs)
                    pbar.n = total_chars  # Ensure the progress bar completes if not already
                    pbar.refresh()
                    pbar.close()
                    return result

                return wrapper
            return decorator

        @with_progress_bar(show_progress=show_progress, refresh_interval=2, prefix_text=f&#34;Processing {self.p_subtype}&#34;)
        def process_marked_text(marked_text, elements_dict, progress_callback=None):
            def break_block(block, elements_dict, progress_callback=None):
                char_pos, line_pos, text = block
                result = []
                last_match_end = 0  # Tracks the end of the last match

                def convert_to_tuples(text_list, progress_callback=None):
                    result = []
                    # Start from the first character
                    current_char_pos = char_pos[0]
                    current_line_pos = line_pos[0]  # Start from the first line

                    for item in text_list:
                        if item is None or len(item) == 0:
                            continue
                        char_start = current_char_pos
                        # -1 because end is inclusive
                        char_end = current_char_pos + len(item) - 1

                        # Count the lines in the current segment
                        lines_in_item = item.count(&#39;\n&#39;)
                        line_start = current_line_pos
                        line_end = current_line_pos + lines_in_item

                        # Update for the next iteration
                        current_char_pos = char_end + 1
                        current_line_pos = line_end + 1 if lines_in_item &gt; 0 else current_line_pos

                        result.append(
                            ((char_start, char_end), (line_start, line_end), item))

                    return result

                def convert_to_element(item, elements_dict, compiled_pattern, progress_callback=None):
                    if progress_callback:
                        progress_callback(item[0][1], block_position=item[0])
                    if compiled_pattern.fullmatch(item[2]):
                        char_pos, line_pos, extracted_text = item

                        if self.p_type == &#34;Block&#34;:
                            if self.p_subtype in AB.blocks:
                                # Create an instance of the class with position parameter
                                element_instance = AB.blocks[self.p_subtype](
                                    extracted_text, char_position=char_pos, line_position=line_pos)
                            else:
                                warnings.warn(
                                    (f&#34;Subtype `{self.p_subtype}`&#34;
                                        f&#34; not recognized. Falling back to Block.&#34;)
                                )
                                element_instance = Block(
                                    extracted_text, char_position=char_pos, line_position=line_pos)
                        elif self.p_type == &#34;Spacer&#34;:
                            element_instance = Spacer(
                                extracted_text, char_position=char_pos, line_position=line_pos)

                        elements_dict[hash(element_instance)] = {
                            &#39;Element&#39;: element_instance, &#39;CharPosition&#39;: char_pos, &#39;LinePosition&#39;: line_pos}

                        return (char_pos, line_pos, element_instance)

                    return item

                def split_by_full_matches(text, compiled_pattern):
                    segments = []
                    start = 0

                    for match in compiled_pattern.finditer(text):
                        # Add the text leading up to the match (if any)
                        if match.start() &gt; start:
                            segments.append(text[start:match.start()])

                        # Add the matched text
                        segments.append(match.group())

                        # Update the start position for the next iteration
                        start = match.end()

                    # Add any remaining text after the last match
                    if start &lt; len(text):
                        segments.append(text[start:])

                    return segments

                # split by full matches instead of re split to allow the internal groups in regex
                text_list = split_by_full_matches(text, compiled_pattern)

                text_list = convert_to_tuples(
                    text_list, progress_callback=progress_callback)

                text_list = [convert_to_element(
                    item, elements_dict, compiled_pattern, progress_callback=progress_callback) for item in text_list]

                return text_list, elements_dict

            i = 0
            while i &lt; len(marked_text):
                # Assuming the structure is [(tuple, tuple, str/Element)]
                if isinstance(marked_text[i][2], str):
                    result, elements_dict = break_block(
                        marked_text[i], elements_dict, progress_callback=progress_callback)
                    if result:
                        # Remove the original item
                        del marked_text[i]

                        # Insert the new items from &#39;result&#39; at position &#39;i&#39;
                        # for item in reversed(result):
                        #     marked_text.insert(i, item)
                        marked_text[i:i] = result

                        # Increment &#39;i&#39; by the number of new items inserted
                        i += len(result)
                    else:
                        # No blocks found, move to the next item
                        i += 1
                else:
                    # The item is not a string, move to the next item
                    i += 1

            return marked_text, elements_dict

        marked_text, elements_dict = process_marked_text(
            marked_text=marked_text, elements_dict=elements_dict)

        return marked_text, elements_dict

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the RegexRequest, which is always 1 for a single request.

        Returns:
            int: The length of the RegexRequest.
        &#34;&#34;&#34;
        return 1

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Provides a string representation of the RegexRequest.

        Returns:
            str: A string representation of the RegexRequest.
        &#34;&#34;&#34;
        pattern = self.pattern if len(
            self.pattern) &lt; 25 else self.pattern[:25] + &#39;...&#39;
        comment = self.comment if len(
            self.comment) &lt; 25 else self.comment[:25] + &#39;...&#39;
        return f&#34;RegexRequest(p_type={self.p_type}, p_subtype={self.p_subtype}, pattern={pattern}, flags={self.flags}, comment={comment})&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.regex_request.RegexRequest.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, marked_text: list[tuple[tuple[int, int], tuple[int, int], <a title="orcaparse.elements.Element" href="elements.html#orcaparse.elements.Element">Element</a>]] | str, mode: str = 'ORCA', show_progress: bool = False) ‑> tuple[str, dict[str, dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the regular expression pattern to the marked text and extract elements.</p>
<h2 id="args">Args</h2>
<dl>
<dt>marked_text (list[tuple[tuple[int, int], tuple[int, int], Element]] | str): The marked text to apply the pattern to.</dt>
<dt>It can be either a list of tuples containing the position, line numbers, and element, or a string.</dt>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode to use for element extraction, either 'ORCA' or 'GPAW'.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>A flag indicating whether to show a progress bar during the extraction process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[str, dict[str, dict]]</code></dt>
<dd>A tuple containing the modified marked text and a dictionary
of extracted elements with their positions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, marked_text: list[tuple[tuple[int, int], tuple[int, int], Element]] | str, mode: str = &#39;ORCA&#39;, show_progress: bool = False) -&gt; tuple[str, dict[str, dict]]:
    &#34;&#34;&#34;
    Apply the regular expression pattern to the marked text and extract elements.

    Args:
        marked_text (list[tuple[tuple[int, int], tuple[int, int], Element]] | str): The marked text to apply the pattern to.
            It can be either a list of tuples containing the position, line numbers, and element, or a string.
        mode (str): The mode to use for element extraction, either &#39;ORCA&#39; or &#39;GPAW&#39;.
        show_progress (bool): A flag indicating whether to show a progress bar during the extraction process.

    Returns:
        tuple[str, dict[str, dict]]: A tuple containing the modified marked text and a dictionary
            of extracted elements with their positions.
    &#34;&#34;&#34;
    if mode == &#39;ORCA&#39;:
        AB = AvailableBlocksOrca
    elif mode == &#39;GPAW&#39;:
        AB = AvailableBlocksGpaw
    else:
        raise ValueError(f&#34;Mode &#39;{mode}&#39; is not recognized.&#34;)

    if isinstance(marked_text, str):
        marked_text = [
            ((0, len(marked_text)), (1, marked_text.count(&#39;\n&#39;) + 1), marked_text)]

    compiled_pattern = self.compile()
    elements_dict = {}

    total_chars = marked_text[-1][0][1]

    # Added prefix_text parameter
    def with_progress_bar(show_progress: bool, refresh_interval: float = 2, prefix_text: str = f&#34;Processing {self.p_subtype}:&#34;):
        def decorator(func):
            if not show_progress:
                return func

            def wrapper(*args, **kwargs):
                nonlocal total_chars  # Assuming total_chars is defined in the outer scope
                # Set prefix text using desc parameter
                pbar = tqdm(total=total_chars, desc=prefix_text)

                last_update_time = time.time()

                # Added optional block_position
                def update_progress(current_char_pos, block_position=None):
                    nonlocal last_update_time
                    current_time = time.time()
                    if current_time - last_update_time &gt;= refresh_interval:
                        pbar.n = current_char_pos
                        if block_position:  # Update postfix text if provided
                            pbar.set_postfix_str(
                                f&#39;Current block position: {block_position}&#39;)
                        pbar.refresh()
                        last_update_time = current_time

                kwargs[&#39;progress_callback&#39;] = update_progress
                result = func(*args, **kwargs)
                pbar.n = total_chars  # Ensure the progress bar completes if not already
                pbar.refresh()
                pbar.close()
                return result

            return wrapper
        return decorator

    @with_progress_bar(show_progress=show_progress, refresh_interval=2, prefix_text=f&#34;Processing {self.p_subtype}&#34;)
    def process_marked_text(marked_text, elements_dict, progress_callback=None):
        def break_block(block, elements_dict, progress_callback=None):
            char_pos, line_pos, text = block
            result = []
            last_match_end = 0  # Tracks the end of the last match

            def convert_to_tuples(text_list, progress_callback=None):
                result = []
                # Start from the first character
                current_char_pos = char_pos[0]
                current_line_pos = line_pos[0]  # Start from the first line

                for item in text_list:
                    if item is None or len(item) == 0:
                        continue
                    char_start = current_char_pos
                    # -1 because end is inclusive
                    char_end = current_char_pos + len(item) - 1

                    # Count the lines in the current segment
                    lines_in_item = item.count(&#39;\n&#39;)
                    line_start = current_line_pos
                    line_end = current_line_pos + lines_in_item

                    # Update for the next iteration
                    current_char_pos = char_end + 1
                    current_line_pos = line_end + 1 if lines_in_item &gt; 0 else current_line_pos

                    result.append(
                        ((char_start, char_end), (line_start, line_end), item))

                return result

            def convert_to_element(item, elements_dict, compiled_pattern, progress_callback=None):
                if progress_callback:
                    progress_callback(item[0][1], block_position=item[0])
                if compiled_pattern.fullmatch(item[2]):
                    char_pos, line_pos, extracted_text = item

                    if self.p_type == &#34;Block&#34;:
                        if self.p_subtype in AB.blocks:
                            # Create an instance of the class with position parameter
                            element_instance = AB.blocks[self.p_subtype](
                                extracted_text, char_position=char_pos, line_position=line_pos)
                        else:
                            warnings.warn(
                                (f&#34;Subtype `{self.p_subtype}`&#34;
                                    f&#34; not recognized. Falling back to Block.&#34;)
                            )
                            element_instance = Block(
                                extracted_text, char_position=char_pos, line_position=line_pos)
                    elif self.p_type == &#34;Spacer&#34;:
                        element_instance = Spacer(
                            extracted_text, char_position=char_pos, line_position=line_pos)

                    elements_dict[hash(element_instance)] = {
                        &#39;Element&#39;: element_instance, &#39;CharPosition&#39;: char_pos, &#39;LinePosition&#39;: line_pos}

                    return (char_pos, line_pos, element_instance)

                return item

            def split_by_full_matches(text, compiled_pattern):
                segments = []
                start = 0

                for match in compiled_pattern.finditer(text):
                    # Add the text leading up to the match (if any)
                    if match.start() &gt; start:
                        segments.append(text[start:match.start()])

                    # Add the matched text
                    segments.append(match.group())

                    # Update the start position for the next iteration
                    start = match.end()

                # Add any remaining text after the last match
                if start &lt; len(text):
                    segments.append(text[start:])

                return segments

            # split by full matches instead of re split to allow the internal groups in regex
            text_list = split_by_full_matches(text, compiled_pattern)

            text_list = convert_to_tuples(
                text_list, progress_callback=progress_callback)

            text_list = [convert_to_element(
                item, elements_dict, compiled_pattern, progress_callback=progress_callback) for item in text_list]

            return text_list, elements_dict

        i = 0
        while i &lt; len(marked_text):
            # Assuming the structure is [(tuple, tuple, str/Element)]
            if isinstance(marked_text[i][2], str):
                result, elements_dict = break_block(
                    marked_text[i], elements_dict, progress_callback=progress_callback)
                if result:
                    # Remove the original item
                    del marked_text[i]

                    # Insert the new items from &#39;result&#39; at position &#39;i&#39;
                    # for item in reversed(result):
                    #     marked_text.insert(i, item)
                    marked_text[i:i] = result

                    # Increment &#39;i&#39; by the number of new items inserted
                    i += len(result)
                else:
                    # No blocks found, move to the next item
                    i += 1
            else:
                # The item is not a string, move to the next item
                i += 1

        return marked_text, elements_dict

    marked_text, elements_dict = process_marked_text(
        marked_text=marked_text, elements_dict=elements_dict)

    return marked_text, elements_dict</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_request.RegexRequest.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self) ‑> Pattern</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles the regex pattern with the specified flags and returns a compiled regex pattern object.</p>
<p>This method allows the user to utilize the compiled pattern object for various regex operations such as <code>findall</code>, <code>search</code>, <code>match</code>, etc.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Pattern</code></dt>
<dd>A compiled regex pattern object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self) -&gt; Pattern:
    &#34;&#34;&#34;
    Compiles the regex pattern with the specified flags and returns a compiled regex pattern object.

    This method allows the user to utilize the compiled pattern object for various regex operations such as `findall`, `search`, `match`, etc.

    Returns:
        Pattern: A compiled regex pattern object.
    &#34;&#34;&#34;
    return re.compile(self.pattern, self.flags)</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_request.RegexRequest.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict[str, typing.Union[str, list[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the RegexRequest instance to a dictionary, including string representations for flags.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Union[str, list[str]]]</code></dt>
<dd>A dictionary representation of the RegexRequest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict[str, Union[str, list[str]]]:
    &#34;&#34;&#34;
    Converts the RegexRequest instance to a dictionary, including string representations for flags.

    Returns:
        dict[str, Union[str, list[str]]]: A dictionary representation of the RegexRequest.
    &#34;&#34;&#34;
    return {
        &#34;p_type&#34;: self.p_type,
        &#34;p_subtype&#34;: self.p_subtype,
        &#34;pattern&#34;: self.pattern,
        &#34;flags&#34;: self._decompile_flags(),
        &#34;comment&#34;: self.comment
    }</code></pre>
</details>
</dd>
<dt id="orcaparse.regex_request.RegexRequest.validate_configuration"><code class="name flex">
<span>def <span class="ident">validate_configuration</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Validates the configuration of the RegexRequest. Currently, this method does not perform any checks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_configuration(self) -&gt; None:
    &#34;&#34;&#34;
    Validates the configuration of the RegexRequest. Currently, this method does not perform any checks.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orcaparse" href="index.html">orcaparse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orcaparse.regex_request.RegexRequest" href="#orcaparse.regex_request.RegexRequest">RegexRequest</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.regex_request.RegexRequest.apply" href="#orcaparse.regex_request.RegexRequest.apply">apply</a></code></li>
<li><code><a title="orcaparse.regex_request.RegexRequest.compile" href="#orcaparse.regex_request.RegexRequest.compile">compile</a></code></li>
<li><code><a title="orcaparse.regex_request.RegexRequest.to_dict" href="#orcaparse.regex_request.RegexRequest.to_dict">to_dict</a></code></li>
<li><code><a title="orcaparse.regex_request.RegexRequest.validate_configuration" href="#orcaparse.regex_request.RegexRequest.validate_configuration">validate_configuration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>