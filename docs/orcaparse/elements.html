<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>orcaparse.elements API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>orcaparse.elements</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import warnings
from datetime import timedelta

import numpy as np
import pandas as pd
from typing_extensions import Self

from .data import Data
from .units_and_constants import ureg


class ExtractionError(Exception):
    &#34;&#34;&#34;Custom exception for energy extraction errors.&#34;&#34;&#34;
    pass


class Element:
    def __init__(self, raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None) -&gt; None:
        &#34;&#34;&#34;
        Initialize an Element with raw data.

        Args:
            raw_data (str): The raw string data associated with this element.
        &#34;&#34;&#34;
        self.raw_data = raw_data
        self.char_position = char_position
        self.line_position = line_position

    def readable_name(self):
        &#34;&#34;&#34;
        Generate a readable name for the element.

        This method should be implemented by subclasses to provide a meaningful name based on the element&#39;s data.

        Returns:
            None by default, indicating the method has not been implemented. Subclasses should override this.
        &#34;&#34;&#34;
        return None

    def get_structure(self) -&gt; dict[Self, tuple | None]:
        &#34;&#34;&#34;
        Retrieve the structural representation of the element.

        The structure is intended as a nested list to represent hierarchical relationships within data.

        Returns:
            A dictionary with the element itself as the key and an empty list as the value, indicating no nested structure by default.
        &#34;&#34;&#34;
        return [self, []]

    def data(self) -&gt; Data:
        &#34;&#34;&#34;
        Process the raw data of the element to extract meaningful information.

        This method should be overridden by subclasses to implement specific data extraction logic.

        Returns:
            Data: An instance of the Data class containing &#39;raw data&#39; as its content, with a comment indicating the absence of specific data extraction procedures.

        Raises:
            Warning: Indicates that no specific procedure for analyzing the data was found.
        &#34;&#34;&#34;
        warnings.warn(
            (f&#34;No procedure for analyzing the data found in type `{type(self)}`,&#34;
             f&#34;returning the raw data:\n{self.raw_data}&#34;)
        )
        return Data(data={&#39;raw data&#39;: self.raw_data},
                    comment=(&#34;No procedure for analyzing the data found, `raw data` collected.\n&#34;
                             &#34;Please contribute to the project if you have knowledge on how to extract data from it.&#34;))

    @staticmethod
    def data_preformat(data_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw body content for HTML display.

        Args:
            body_raw (str): The raw body text to be formatted.

        Returns:
            str: The formatted body text wrapped in HTML &lt;pre&gt; tags.
        &#34;&#34;&#34;
        return f&#39;&lt;pre&gt;{data_raw}&lt;/pre&gt;&#39;

    def to_html(self) -&gt; str:
        &#34;&#34;&#34;
        Generate an HTML representation of the element.

        This method provides a basic HTML structure for displaying the element&#39;s data. Subclasses may override this method for more specialized HTML representations.

        Returns:
            str: A string containing the HTML representation of the element.
        &#34;&#34;&#34;
        data = self.raw_data
        is_block = isinstance(self, Block)
        line_start, line_finish = self.line_position or (-1, -1)
        return (f&#39;&lt;div class=&#34;element&#34; &#39;
                f&#39;python-class-name=&#34;{self.__class__.__name__}&#34; &#39;
                f&#39;start-line={line_start} finish-line={line_finish} &#39;
                f&#39;is-block=&#34;{is_block}&#34;&gt;\n{self.data_preformat(data)}&lt;/div&gt;&#39;)

    def depth(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate the depth of nested structures within the element.

        This method recursively computes the maximum depth of nested lists representing the structure of the element.

        Returns:
            int: The maximum depth of the element&#39;s structure.
        &#34;&#34;&#34;
        return Element.max_depth(self.get_structure())

    @staticmethod
    def max_depth(d) -&gt; int:
        &#34;&#34;&#34;
        Compute the maximum depth of a nested list structure.

        This static method assists in calculating the depth of an element&#39;s structure.

        Args:
            d (list): A nested list representing the structure of an element.

        Returns:
            int: The maximum depth of the nested list structure.
        &#34;&#34;&#34;
        if isinstance(d, list) and len(d) &gt; 0:
            return 1 + max(Element.max_depth(v) for v in d)
        return 0

    @staticmethod
    def process_invalid_name(input_string: str) -&gt; str:
        &#34;&#34;&#34;
        Clean and process an input string to generate a valid name.

        This method is used to sanitize input strings that may contain invalid characters or formatting. It ensures the output is suitable for use as a name or identifier.

        Args:
            input_string (str): The input string to be processed.

        Returns:
            str: A cleaned and truncated version of the input string, made suitable for use as a name or identifier.
        &#34;&#34;&#34;
        # Check if the string contains any letters; if not, return &#34;unknown&#34;
        if not any(char.isalpha() for char in input_string):
            cleaned_string = &#39;&#39;.join(
                char for char in input_string if not char.isspace())
            return &#34;Unknown: &#34; + cleaned_string[:21] + (&#39;&#39; if len(cleaned_string) &lt; 19 else &#39;...&#39;)

        # Remove all characters that are not letters or spaces
        cleaned_string = &#39;&#39;.join(
            char for char in input_string if char.isalpha() or char.isspace())
        single_spaced_text = re.sub(r&#39;\s+&#39;, &#39; &#39;, cleaned_string)
        if single_spaced_text.startswith(&#39; &#39;):
            single_spaced_text = single_spaced_text[1:]

        # Return the first 30 characters of the cleaned string
        return single_spaced_text[:30] + (&#39;&#39; if len(single_spaced_text) &lt; 28 else &#39;...&#39;)


class Spacer(Element):
    def data(self) -&gt; None:
        &#34;&#34;&#34;
        Override the data method to return None for a Spacer.

        Since a Spacer is intended to represent empty space or a separator, it does not contain meaningful data to be processed or extracted.

        Returns:
            None: Indicating that there is no data associated with this Spacer.
        &#34;&#34;&#34;
        return None

    @staticmethod
    def data_preformat(data_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw body content for HTML display.

        Args:
            body_raw (str): The raw body text to be formatted.

        Returns:
            str: spacer with \\n replaced by &lt;br&gt;
        &#34;&#34;&#34;
        return data_raw.replace(&#39;\n&#39;, &#39;&lt;br&gt;&#39;)


class Block(Element):
    &#34;&#34;&#34;
    Represents a block of data within a structured document.

    A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.

    Attributes:
        data_available (bool): Indicates whether the block contains data that can be extracted. Defaults to False.
        position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
    &#34;&#34;&#34;
    data_available: bool = False

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        &#34;&#34;&#34;
        Extract and separate the block&#39;s name, header, and body components.

        This method provides a basic implementation that simply identifies the block&#39;s name using a naming convention. Subclasses should override this method to implement more complex extraction logic.

        Returns:
            tuple[str, str | None, str]: A tuple containing the block&#39;s name, header (or None if not applicable), and body.
        &#34;&#34;&#34;
        return Element.process_invalid_name(self.raw_data), None, self.raw_data

    def readable_name(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve a readable name for the block.

        Returns:
            str: The name of the block, extracted using the `extract_name_header_and_body` method.
        &#34;&#34;&#34;
        return self.extract_name_header_and_body()[0]

    def header(self) -&gt; str | None:
        &#34;&#34;&#34;
        Retrieve the header of the block, if present.

        Returns:
            str | None: The header of the block or None if no header is present. Determined using the `extract_name_header_and_body` method.
        &#34;&#34;&#34;
        return self.extract_name_header_and_body()[1]

    def body(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve the body content of the block.

        Returns:
            str: The body of the block, determined using the `extract_name_header_and_body` method.
        &#34;&#34;&#34;
        return self.extract_name_header_and_body()[2]

    @staticmethod
    def header_preformat(header_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw header content for HTML display.

        Args:
            header_raw (str): The raw header text to be formatted.

        Returns:
            str: The formatted header text wrapped in HTML &lt;pre&gt; tags.
        &#34;&#34;&#34;
        return f&#39;&lt;pre&gt;{header_raw}&lt;/pre&gt;&#39;

    @staticmethod
    def body_preformat(body_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw body content for HTML display.

        Args:
            body_raw (str): The raw body text to be formatted.

        Returns:
            str: The formatted body text wrapped in HTML &lt;pre&gt; tags.
        &#34;&#34;&#34;
        return f&#39;&lt;pre&gt;{body_raw}&lt;/pre&gt;&#39;

    def to_html(self) -&gt; str:
        &#34;&#34;&#34;
        Generate an HTML representation of the block.

        This method constructs the HTML structure for the block, including its name, header (if present), and body. The depth of the block within the document structure is considered when determining the header&#39;s level.

        Returns:
            str: A string containing the HTML representation of the block.
        &#34;&#34;&#34;
        readable_name, header, body = self.extract_name_header_and_body()
        header_level = max(7-self.depth(), 1)
        header_html = (f&#39;&lt;div class=&#34;header&#34;&gt;&lt;h{header_level}&gt;\n&#39;
                       f&#39;{self.header_preformat(header)}&#39;
                       f&#39;&lt;/h{header_level}&gt;&lt;/div&gt;&#39;
                       f&#39;&lt;hr class=&#34;hr-in-block&#34;&gt;&lt;/hr&gt;&#39;) if header else &#39;&#39;
        body_html = (f&#39;&lt;div class=&#34;data&#34;&gt;\n&#39;
                     f&#39;{self.body_preformat(body)}&#39;
                     f&#39;&lt;/div&gt;&#39;) if body else &#39;&#39;
        line_start, line_finish = self.line_position or (-1, -1)
        can_extract_data = self.data_available
        is_block = True
        return (f&#39;&lt;div class=&#34;element block&#34; &#39;
                f&#39;python-class-name=&#34;{self.__class__.__name__}&#34; &#39;
                f&#39;readable-name=&#34;{readable_name}&#34; &#39;
                f&#39;start-line={line_start} finish-line={line_finish} &#39;
                f&#39;data_available={can_extract_data}&gt;&#39;
                f&#39;{header_html+body_html}&lt;/div&gt;&#39;
                f&#39;&lt;hr class = &#34;hr-between-blocks&#34;&gt;&lt;/hr&gt;&#39;)


class AvailableBlocksGeneral:
    &#34;&#34;&#34;
    A registry for managing different types of block elements.

    This class maintains a dictionary of all available block types that can be dynamically extended. New block classes can be registered using the provided class methods, facilitating modularity and extensibility.
    &#34;&#34;&#34;
    # Dictionary to hold all available block types.
    blocks: dict[str, type[Element]] = {}

    @classmethod
    def register_block(cls, block_cls: type[Element]) -&gt; type[Element]:
        &#34;&#34;&#34;
        Decorator to register a new block type in the blocks dictionary.

        If a block class with the same name is already registered, this method raises a ValueError to prevent unintentional overwrites.

        Args:
            block_cls (type[Element]): The block class to be registered.

        Returns:
            type[Element]: The same block class that was passed in, enabling this method to be used as a decorator.

        Raises:
            ValueError: If a block with the same class name is already registered.
        &#34;&#34;&#34;
        block_name = block_cls.__name__
        if block_name in cls.blocks:
            raise ValueError(f&#34;Block type {block_name} is already defined.&#34;)
        cls.blocks[block_name] = block_cls
        return block_cls

    @classmethod
    def rewrite_block(cls, block_cls: type[Element]) -&gt; type[Element]:
        &#34;&#34;&#34;
        Decorator to register or overwrite an existing block type in the blocks dictionary.

        Unlike `register_block`, this method allows for the redefinition of block types. If a block with the same name already exists, it will be overwritten with the new definition.

        Args:
            block_cls (type[Element]): The block class to be registered or redefined.

        Returns:
            type[Element]: The same block class that was passed in, enabling this method to be used as a decorator.
        &#34;&#34;&#34;
        block_name = block_cls.__name__
        cls.blocks[block_name] = block_cls
        return block_cls


class BlockUnknown(Block):
    def data(self):
        warnings.warn(
            f&#39;The block looks not structured. Please contribute to the project if you have knowledge on how to extract data from it.&#39;)
        return Data(data={&#39;raw data&#39;: self.raw_data},
                    comment=(&#34;No procedure for analyzing the data found, furthermore, the block looks not structured `raw data` collected.\n&#34;
                             &#34;Please contribute to the project if you have knowledge on how to extract data from it.&#34;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="orcaparse.elements.AvailableBlocksGeneral"><code class="flex name class">
<span>class <span class="ident">AvailableBlocksGeneral</span></span>
</code></dt>
<dd>
<div class="desc"><p>A registry for managing different types of block elements.</p>
<p>This class maintains a dictionary of all available block types that can be dynamically extended. New block classes can be registered using the provided class methods, facilitating modularity and extensibility.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AvailableBlocksGeneral:
    &#34;&#34;&#34;
    A registry for managing different types of block elements.

    This class maintains a dictionary of all available block types that can be dynamically extended. New block classes can be registered using the provided class methods, facilitating modularity and extensibility.
    &#34;&#34;&#34;
    # Dictionary to hold all available block types.
    blocks: dict[str, type[Element]] = {}

    @classmethod
    def register_block(cls, block_cls: type[Element]) -&gt; type[Element]:
        &#34;&#34;&#34;
        Decorator to register a new block type in the blocks dictionary.

        If a block class with the same name is already registered, this method raises a ValueError to prevent unintentional overwrites.

        Args:
            block_cls (type[Element]): The block class to be registered.

        Returns:
            type[Element]: The same block class that was passed in, enabling this method to be used as a decorator.

        Raises:
            ValueError: If a block with the same class name is already registered.
        &#34;&#34;&#34;
        block_name = block_cls.__name__
        if block_name in cls.blocks:
            raise ValueError(f&#34;Block type {block_name} is already defined.&#34;)
        cls.blocks[block_name] = block_cls
        return block_cls

    @classmethod
    def rewrite_block(cls, block_cls: type[Element]) -&gt; type[Element]:
        &#34;&#34;&#34;
        Decorator to register or overwrite an existing block type in the blocks dictionary.

        Unlike `register_block`, this method allows for the redefinition of block types. If a block with the same name already exists, it will be overwritten with the new definition.

        Args:
            block_cls (type[Element]): The block class to be registered or redefined.

        Returns:
            type[Element]: The same block class that was passed in, enabling this method to be used as a decorator.
        &#34;&#34;&#34;
        block_name = block_cls.__name__
        cls.blocks[block_name] = block_cls
        return block_cls</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="orcaparse.gpaw_elements.AvailableBlocksGpaw" href="gpaw_elements.html#orcaparse.gpaw_elements.AvailableBlocksGpaw">AvailableBlocksGpaw</a></li>
<li><a title="orcaparse.orca_elements.AvailableBlocksOrca" href="orca_elements.html#orcaparse.orca_elements.AvailableBlocksOrca">AvailableBlocksOrca</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.elements.AvailableBlocksGeneral.blocks"><code class="name">var <span class="ident">blocks</span> : dict[str, type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="orcaparse.elements.AvailableBlocksGeneral.register_block"><code class="name flex">
<span>def <span class="ident">register_block</span></span>(<span>block_cls: type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]) ‑> type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to register a new block type in the blocks dictionary.</p>
<p>If a block class with the same name is already registered, this method raises a ValueError to prevent unintentional overwrites.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>block_cls</code></strong> :&ensp;<code>type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]</code></dt>
<dd>The block class to be registered.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]</code></dt>
<dd>The same block class that was passed in, enabling this method to be used as a decorator.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If a block with the same class name is already registered.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def register_block(cls, block_cls: type[Element]) -&gt; type[Element]:
    &#34;&#34;&#34;
    Decorator to register a new block type in the blocks dictionary.

    If a block class with the same name is already registered, this method raises a ValueError to prevent unintentional overwrites.

    Args:
        block_cls (type[Element]): The block class to be registered.

    Returns:
        type[Element]: The same block class that was passed in, enabling this method to be used as a decorator.

    Raises:
        ValueError: If a block with the same class name is already registered.
    &#34;&#34;&#34;
    block_name = block_cls.__name__
    if block_name in cls.blocks:
        raise ValueError(f&#34;Block type {block_name} is already defined.&#34;)
    cls.blocks[block_name] = block_cls
    return block_cls</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.AvailableBlocksGeneral.rewrite_block"><code class="name flex">
<span>def <span class="ident">rewrite_block</span></span>(<span>block_cls: type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]) ‑> type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to register or overwrite an existing block type in the blocks dictionary.</p>
<p>Unlike <code>register_block</code>, this method allows for the redefinition of block types. If a block with the same name already exists, it will be overwritten with the new definition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>block_cls</code></strong> :&ensp;<code>type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]</code></dt>
<dd>The block class to be registered or redefined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>type[<a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a>]</code></dt>
<dd>The same block class that was passed in, enabling this method to be used as a decorator.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rewrite_block(cls, block_cls: type[Element]) -&gt; type[Element]:
    &#34;&#34;&#34;
    Decorator to register or overwrite an existing block type in the blocks dictionary.

    Unlike `register_block`, this method allows for the redefinition of block types. If a block with the same name already exists, it will be overwritten with the new definition.

    Args:
        block_cls (type[Element]): The block class to be registered or redefined.

    Returns:
        type[Element]: The same block class that was passed in, enabling this method to be used as a decorator.
    &#34;&#34;&#34;
    block_name = block_cls.__name__
    cls.blocks[block_name] = block_cls
    return block_cls</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="orcaparse.elements.Block"><code class="flex name class">
<span>class <span class="ident">Block</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Block(Element):
    &#34;&#34;&#34;
    Represents a block of data within a structured document.

    A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.

    Attributes:
        data_available (bool): Indicates whether the block contains data that can be extracted. Defaults to False.
        position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
    &#34;&#34;&#34;
    data_available: bool = False

    def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
        &#34;&#34;&#34;
        Extract and separate the block&#39;s name, header, and body components.

        This method provides a basic implementation that simply identifies the block&#39;s name using a naming convention. Subclasses should override this method to implement more complex extraction logic.

        Returns:
            tuple[str, str | None, str]: A tuple containing the block&#39;s name, header (or None if not applicable), and body.
        &#34;&#34;&#34;
        return Element.process_invalid_name(self.raw_data), None, self.raw_data

    def readable_name(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve a readable name for the block.

        Returns:
            str: The name of the block, extracted using the `extract_name_header_and_body` method.
        &#34;&#34;&#34;
        return self.extract_name_header_and_body()[0]

    def header(self) -&gt; str | None:
        &#34;&#34;&#34;
        Retrieve the header of the block, if present.

        Returns:
            str | None: The header of the block or None if no header is present. Determined using the `extract_name_header_and_body` method.
        &#34;&#34;&#34;
        return self.extract_name_header_and_body()[1]

    def body(self) -&gt; str:
        &#34;&#34;&#34;
        Retrieve the body content of the block.

        Returns:
            str: The body of the block, determined using the `extract_name_header_and_body` method.
        &#34;&#34;&#34;
        return self.extract_name_header_and_body()[2]

    @staticmethod
    def header_preformat(header_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw header content for HTML display.

        Args:
            header_raw (str): The raw header text to be formatted.

        Returns:
            str: The formatted header text wrapped in HTML &lt;pre&gt; tags.
        &#34;&#34;&#34;
        return f&#39;&lt;pre&gt;{header_raw}&lt;/pre&gt;&#39;

    @staticmethod
    def body_preformat(body_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw body content for HTML display.

        Args:
            body_raw (str): The raw body text to be formatted.

        Returns:
            str: The formatted body text wrapped in HTML &lt;pre&gt; tags.
        &#34;&#34;&#34;
        return f&#39;&lt;pre&gt;{body_raw}&lt;/pre&gt;&#39;

    def to_html(self) -&gt; str:
        &#34;&#34;&#34;
        Generate an HTML representation of the block.

        This method constructs the HTML structure for the block, including its name, header (if present), and body. The depth of the block within the document structure is considered when determining the header&#39;s level.

        Returns:
            str: A string containing the HTML representation of the block.
        &#34;&#34;&#34;
        readable_name, header, body = self.extract_name_header_and_body()
        header_level = max(7-self.depth(), 1)
        header_html = (f&#39;&lt;div class=&#34;header&#34;&gt;&lt;h{header_level}&gt;\n&#39;
                       f&#39;{self.header_preformat(header)}&#39;
                       f&#39;&lt;/h{header_level}&gt;&lt;/div&gt;&#39;
                       f&#39;&lt;hr class=&#34;hr-in-block&#34;&gt;&lt;/hr&gt;&#39;) if header else &#39;&#39;
        body_html = (f&#39;&lt;div class=&#34;data&#34;&gt;\n&#39;
                     f&#39;{self.body_preformat(body)}&#39;
                     f&#39;&lt;/div&gt;&#39;) if body else &#39;&#39;
        line_start, line_finish = self.line_position or (-1, -1)
        can_extract_data = self.data_available
        is_block = True
        return (f&#39;&lt;div class=&#34;element block&#34; &#39;
                f&#39;python-class-name=&#34;{self.__class__.__name__}&#34; &#39;
                f&#39;readable-name=&#34;{readable_name}&#34; &#39;
                f&#39;start-line={line_start} finish-line={line_finish} &#39;
                f&#39;data_available={can_extract_data}&gt;&#39;
                f&#39;{header_html+body_html}&lt;/div&gt;&#39;
                f&#39;&lt;hr class = &#34;hr-between-blocks&#34;&gt;&lt;/hr&gt;&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.BlockUnknown" href="#orcaparse.elements.BlockUnknown">BlockUnknown</a></li>
<li><a title="orcaparse.gpaw_elements.BlockGpawDipole" href="gpaw_elements.html#orcaparse.gpaw_elements.BlockGpawDipole">BlockGpawDipole</a></li>
<li><a title="orcaparse.gpaw_elements.BlockGpawIcon" href="gpaw_elements.html#orcaparse.gpaw_elements.BlockGpawIcon">BlockGpawIcon</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaAllRightsReserved" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaAllRightsReserved">BlockOrcaAllRightsReserved</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaFinalSinglePointEnergy">BlockOrcaFinalSinglePointEnergy</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaIcon" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaIcon">BlockOrcaIcon</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaScfConverged" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaScfConverged">BlockOrcaScfConverged</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaTerminatedNormally" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaTerminatedNormally">BlockOrcaTerminatedNormally</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaTimingsForIndividualModules">BlockOrcaTimingsForIndividualModules</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaTotalRunTime" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaTotalRunTime">BlockOrcaTotalRunTime</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaUnrecognizedMessage" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaUnrecognizedMessage">BlockOrcaUnrecognizedMessage</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaUnrecognizedNotification" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaUnrecognizedNotification">BlockOrcaUnrecognizedNotification</a></li>
<li><a title="orcaparse.orca_elements.BlockOrcaWithStandardHeader" href="orca_elements.html#orcaparse.orca_elements.BlockOrcaWithStandardHeader">BlockOrcaWithStandardHeader</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="orcaparse.elements.Block.data_available"><code class="name">var <span class="ident">data_available</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="orcaparse.elements.Block.body_preformat"><code class="name flex">
<span>def <span class="ident">body_preformat</span></span>(<span>body_raw: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format the raw body content for HTML display.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>body_raw</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw body text to be formatted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted body text wrapped in HTML <pre> tags.</dd>
</dl></div>
  
    
      <details class="source">
        <summary>
            <span>Expand source code</span>
        </summary>
        <pre><code class="python">@staticmethod
def body_preformat(body_raw: str) -&gt; str:
    &#34;&#34;&#34;
    Format the raw body content for HTML display.

    Args:
        body_raw (str): The raw body text to be formatted.

    Returns:
        str: The formatted body text wrapped in HTML &lt;pre&gt; tags.
    &#34;&#34;&#34;
    return f&#39;&lt;pre&gt;{body_raw}&lt;/pre&gt;&#39;</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Block.header_preformat"><code class="name flex">
<span>def <span class="ident">header_preformat</span></span>(<span>header_raw: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format the raw header content for HTML display.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>header_raw</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw header text to be formatted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted header text wrapped in HTML <pre> tags.</dd>
</dl></div>
  
    
      <details class="source">
        <summary>
            <span>Expand source code</span>
        </summary>
        <pre><code class="python">@staticmethod
def header_preformat(header_raw: str) -&gt; str:
    &#34;&#34;&#34;
    Format the raw header content for HTML display.

    Args:
        header_raw (str): The raw header text to be formatted.

    Returns:
        str: The formatted header text wrapped in HTML &lt;pre&gt; tags.
    &#34;&#34;&#34;
    return f&#39;&lt;pre&gt;{header_raw}&lt;/pre&gt;&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.elements.Block.body"><code class="name flex">
<span>def <span class="ident">body</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the body content of the block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The body of the block, determined using the <code>extract_name_header_and_body</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def body(self) -&gt; str:
    &#34;&#34;&#34;
    Retrieve the body content of the block.

    Returns:
        str: The body of the block, determined using the `extract_name_header_and_body` method.
    &#34;&#34;&#34;
    return self.extract_name_header_and_body()[2]</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Block.extract_name_header_and_body"><code class="name flex">
<span>def <span class="ident">extract_name_header_and_body</span></span>(<span>self) ‑> tuple[str, str | None, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract and separate the block's name, header, and body components.</p>
<p>This method provides a basic implementation that simply identifies the block's name using a naming convention. Subclasses should override this method to implement more complex extraction logic.</p>
<h2 id="returns">Returns</h2>
<p>tuple[str, str | None, str]: A tuple containing the block's name, header (or None if not applicable), and body.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_name_header_and_body(self) -&gt; tuple[str, str | None, str]:
    &#34;&#34;&#34;
    Extract and separate the block&#39;s name, header, and body components.

    This method provides a basic implementation that simply identifies the block&#39;s name using a naming convention. Subclasses should override this method to implement more complex extraction logic.

    Returns:
        tuple[str, str | None, str]: A tuple containing the block&#39;s name, header (or None if not applicable), and body.
    &#34;&#34;&#34;
    return Element.process_invalid_name(self.raw_data), None, self.raw_data</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Block.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self) ‑> str | None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the header of the block, if present.</p>
<h2 id="returns">Returns</h2>
<p>str | None: The header of the block or None if no header is present. Determined using the <code>extract_name_header_and_body</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self) -&gt; str | None:
    &#34;&#34;&#34;
    Retrieve the header of the block, if present.

    Returns:
        str | None: The header of the block or None if no header is present. Determined using the `extract_name_header_and_body` method.
    &#34;&#34;&#34;
    return self.extract_name_header_and_body()[1]</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Block.readable_name"><code class="name flex">
<span>def <span class="ident">readable_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a readable name for the block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The name of the block, extracted using the <code>extract_name_header_and_body</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readable_name(self) -&gt; str:
    &#34;&#34;&#34;
    Retrieve a readable name for the block.

    Returns:
        str: The name of the block, extracted using the `extract_name_header_and_body` method.
    &#34;&#34;&#34;
    return self.extract_name_header_and_body()[0]</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Block.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an HTML representation of the block.</p>
<p>This method constructs the HTML structure for the block, including its name, header (if present), and body. The depth of the block within the document structure is considered when determining the header's level.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string containing the HTML representation of the block.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_html(self) -&gt; str:
    &#34;&#34;&#34;
    Generate an HTML representation of the block.

    This method constructs the HTML structure for the block, including its name, header (if present), and body. The depth of the block within the document structure is considered when determining the header&#39;s level.

    Returns:
        str: A string containing the HTML representation of the block.
    &#34;&#34;&#34;
    readable_name, header, body = self.extract_name_header_and_body()
    header_level = max(7-self.depth(), 1)
    header_html = (f&#39;&lt;div class=&#34;header&#34;&gt;&lt;h{header_level}&gt;\n&#39;
                   f&#39;{self.header_preformat(header)}&#39;
                   f&#39;&lt;/h{header_level}&gt;&lt;/div&gt;&#39;
                   f&#39;&lt;hr class=&#34;hr-in-block&#34;&gt;&lt;/hr&gt;&#39;) if header else &#39;&#39;
    body_html = (f&#39;&lt;div class=&#34;data&#34;&gt;\n&#39;
                 f&#39;{self.body_preformat(body)}&#39;
                 f&#39;&lt;/div&gt;&#39;) if body else &#39;&#39;
    line_start, line_finish = self.line_position or (-1, -1)
    can_extract_data = self.data_available
    is_block = True
    return (f&#39;&lt;div class=&#34;element block&#34; &#39;
            f&#39;python-class-name=&#34;{self.__class__.__name__}&#34; &#39;
            f&#39;readable-name=&#34;{readable_name}&#34; &#39;
            f&#39;start-line={line_start} finish-line={line_finish} &#39;
            f&#39;data_available={can_extract_data}&gt;&#39;
            f&#39;{header_html+body_html}&lt;/div&gt;&#39;
            f&#39;&lt;hr class = &#34;hr-between-blocks&#34;&gt;&lt;/hr&gt;&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Element.data" href="#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Element.data_preformat" href="#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Element.depth" href="#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Element.get_structure" href="#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Element.max_depth" href="#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Element.process_invalid_name" href="#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.elements.BlockUnknown"><code class="flex name class">
<span>class <span class="ident">BlockUnknown</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a block of data within a structured document.</p>
<p>A Block is an extension of the Element class, intended to encapsulate a more complex structure that may include a name, header, and body. This class provides methods to extract and present these components in various formats, including HTML.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_available</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates whether the block contains data that can be extracted. Defaults to False.</dd>
</dl>
<p>position (tuple | None): The position of the block within the larger data structure, typically as a line number range.
Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockUnknown(Block):
    def data(self):
        warnings.warn(
            f&#39;The block looks not structured. Please contribute to the project if you have knowledge on how to extract data from it.&#39;)
        return Data(data={&#39;raw data&#39;: self.raw_data},
                    comment=(&#34;No procedure for analyzing the data found, furthermore, the block looks not structured `raw data` collected.\n&#34;
                             &#34;Please contribute to the project if you have knowledge on how to extract data from it.&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Block" href="#orcaparse.elements.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Block.body" href="#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data" href="#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_preformat" href="#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.depth" href="#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.get_structure" href="#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.max_depth" href="#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Block.process_invalid_name" href="#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="orcaparse.elements.Element"><code class="flex name class">
<span>class <span class="ident">Element</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Element:
    def __init__(self, raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None) -&gt; None:
        &#34;&#34;&#34;
        Initialize an Element with raw data.

        Args:
            raw_data (str): The raw string data associated with this element.
        &#34;&#34;&#34;
        self.raw_data = raw_data
        self.char_position = char_position
        self.line_position = line_position

    def readable_name(self):
        &#34;&#34;&#34;
        Generate a readable name for the element.

        This method should be implemented by subclasses to provide a meaningful name based on the element&#39;s data.

        Returns:
            None by default, indicating the method has not been implemented. Subclasses should override this.
        &#34;&#34;&#34;
        return None

    def get_structure(self) -&gt; dict[Self, tuple | None]:
        &#34;&#34;&#34;
        Retrieve the structural representation of the element.

        The structure is intended as a nested list to represent hierarchical relationships within data.

        Returns:
            A dictionary with the element itself as the key and an empty list as the value, indicating no nested structure by default.
        &#34;&#34;&#34;
        return [self, []]

    def data(self) -&gt; Data:
        &#34;&#34;&#34;
        Process the raw data of the element to extract meaningful information.

        This method should be overridden by subclasses to implement specific data extraction logic.

        Returns:
            Data: An instance of the Data class containing &#39;raw data&#39; as its content, with a comment indicating the absence of specific data extraction procedures.

        Raises:
            Warning: Indicates that no specific procedure for analyzing the data was found.
        &#34;&#34;&#34;
        warnings.warn(
            (f&#34;No procedure for analyzing the data found in type `{type(self)}`,&#34;
             f&#34;returning the raw data:\n{self.raw_data}&#34;)
        )
        return Data(data={&#39;raw data&#39;: self.raw_data},
                    comment=(&#34;No procedure for analyzing the data found, `raw data` collected.\n&#34;
                             &#34;Please contribute to the project if you have knowledge on how to extract data from it.&#34;))

    @staticmethod
    def data_preformat(data_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw body content for HTML display.

        Args:
            body_raw (str): The raw body text to be formatted.

        Returns:
            str: The formatted body text wrapped in HTML &lt;pre&gt; tags.
        &#34;&#34;&#34;
        return f&#39;&lt;pre&gt;{data_raw}&lt;/pre&gt;&#39;

    def to_html(self) -&gt; str:
        &#34;&#34;&#34;
        Generate an HTML representation of the element.

        This method provides a basic HTML structure for displaying the element&#39;s data. Subclasses may override this method for more specialized HTML representations.

        Returns:
            str: A string containing the HTML representation of the element.
        &#34;&#34;&#34;
        data = self.raw_data
        is_block = isinstance(self, Block)
        line_start, line_finish = self.line_position or (-1, -1)
        return (f&#39;&lt;div class=&#34;element&#34; &#39;
                f&#39;python-class-name=&#34;{self.__class__.__name__}&#34; &#39;
                f&#39;start-line={line_start} finish-line={line_finish} &#39;
                f&#39;is-block=&#34;{is_block}&#34;&gt;\n{self.data_preformat(data)}&lt;/div&gt;&#39;)

    def depth(self) -&gt; int:
        &#34;&#34;&#34;
        Calculate the depth of nested structures within the element.

        This method recursively computes the maximum depth of nested lists representing the structure of the element.

        Returns:
            int: The maximum depth of the element&#39;s structure.
        &#34;&#34;&#34;
        return Element.max_depth(self.get_structure())

    @staticmethod
    def max_depth(d) -&gt; int:
        &#34;&#34;&#34;
        Compute the maximum depth of a nested list structure.

        This static method assists in calculating the depth of an element&#39;s structure.

        Args:
            d (list): A nested list representing the structure of an element.

        Returns:
            int: The maximum depth of the nested list structure.
        &#34;&#34;&#34;
        if isinstance(d, list) and len(d) &gt; 0:
            return 1 + max(Element.max_depth(v) for v in d)
        return 0

    @staticmethod
    def process_invalid_name(input_string: str) -&gt; str:
        &#34;&#34;&#34;
        Clean and process an input string to generate a valid name.

        This method is used to sanitize input strings that may contain invalid characters or formatting. It ensures the output is suitable for use as a name or identifier.

        Args:
            input_string (str): The input string to be processed.

        Returns:
            str: A cleaned and truncated version of the input string, made suitable for use as a name or identifier.
        &#34;&#34;&#34;
        # Check if the string contains any letters; if not, return &#34;unknown&#34;
        if not any(char.isalpha() for char in input_string):
            cleaned_string = &#39;&#39;.join(
                char for char in input_string if not char.isspace())
            return &#34;Unknown: &#34; + cleaned_string[:21] + (&#39;&#39; if len(cleaned_string) &lt; 19 else &#39;...&#39;)

        # Remove all characters that are not letters or spaces
        cleaned_string = &#39;&#39;.join(
            char for char in input_string if char.isalpha() or char.isspace())
        single_spaced_text = re.sub(r&#39;\s+&#39;, &#39; &#39;, cleaned_string)
        if single_spaced_text.startswith(&#39; &#39;):
            single_spaced_text = single_spaced_text[1:]

        # Return the first 30 characters of the cleaned string
        return single_spaced_text[:30] + (&#39;&#39; if len(single_spaced_text) &lt; 28 else &#39;...&#39;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Block" href="#orcaparse.elements.Block">Block</a></li>
<li><a title="orcaparse.elements.Spacer" href="#orcaparse.elements.Spacer">Spacer</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="orcaparse.elements.Element.data_preformat"><code class="name flex">
<span>def <span class="ident">data_preformat</span></span>(<span>data_raw: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format the raw body content for HTML display.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>body_raw</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw body text to be formatted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted body text wrapped in HTML <pre> tags.</dd>
</dl></div>
  
    
      <details class="source">
        <summary>
            <span>Expand source code</span>
        </summary>
        <pre><code class="python">@staticmethod
def data_preformat(data_raw: str) -&gt; str:
    &#34;&#34;&#34;
    Format the raw body content for HTML display.

    Args:
        body_raw (str): The raw body text to be formatted.

    Returns:
        str: The formatted body text wrapped in HTML &lt;pre&gt; tags.
    &#34;&#34;&#34;
    return f&#39;&lt;pre&gt;{data_raw}&lt;/pre&gt;&#39;</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Element.max_depth"><code class="name flex">
<span>def <span class="ident">max_depth</span></span>(<span>d) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the maximum depth of a nested list structure.</p>
<p>This static method assists in calculating the depth of an element's structure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>list</code></dt>
<dd>A nested list representing the structure of an element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The maximum depth of the nested list structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def max_depth(d) -&gt; int:
    &#34;&#34;&#34;
    Compute the maximum depth of a nested list structure.

    This static method assists in calculating the depth of an element&#39;s structure.

    Args:
        d (list): A nested list representing the structure of an element.

    Returns:
        int: The maximum depth of the nested list structure.
    &#34;&#34;&#34;
    if isinstance(d, list) and len(d) &gt; 0:
        return 1 + max(Element.max_depth(v) for v in d)
    return 0</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Element.process_invalid_name"><code class="name flex">
<span>def <span class="ident">process_invalid_name</span></span>(<span>input_string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Clean and process an input string to generate a valid name.</p>
<p>This method is used to sanitize input strings that may contain invalid characters or formatting. It ensures the output is suitable for use as a name or identifier.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to be processed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A cleaned and truncated version of the input string, made suitable for use as a name or identifier.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process_invalid_name(input_string: str) -&gt; str:
    &#34;&#34;&#34;
    Clean and process an input string to generate a valid name.

    This method is used to sanitize input strings that may contain invalid characters or formatting. It ensures the output is suitable for use as a name or identifier.

    Args:
        input_string (str): The input string to be processed.

    Returns:
        str: A cleaned and truncated version of the input string, made suitable for use as a name or identifier.
    &#34;&#34;&#34;
    # Check if the string contains any letters; if not, return &#34;unknown&#34;
    if not any(char.isalpha() for char in input_string):
        cleaned_string = &#39;&#39;.join(
            char for char in input_string if not char.isspace())
        return &#34;Unknown: &#34; + cleaned_string[:21] + (&#39;&#39; if len(cleaned_string) &lt; 19 else &#39;...&#39;)

    # Remove all characters that are not letters or spaces
    cleaned_string = &#39;&#39;.join(
        char for char in input_string if char.isalpha() or char.isspace())
    single_spaced_text = re.sub(r&#39;\s+&#39;, &#39; &#39;, cleaned_string)
    if single_spaced_text.startswith(&#39; &#39;):
        single_spaced_text = single_spaced_text[1:]

    # Return the first 30 characters of the cleaned string
    return single_spaced_text[:30] + (&#39;&#39; if len(single_spaced_text) &lt; 28 else &#39;...&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.elements.Element.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> <a title="orcaparse.data.Data" href="data.html#orcaparse.data.Data">Data</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process the raw data of the element to extract meaningful information.</p>
<p>This method should be overridden by subclasses to implement specific data extraction logic.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Data</code></dt>
<dd>An instance of the Data class containing 'raw data' as its content, with a comment indicating the absence of specific data extraction procedures.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Warning</code></dt>
<dd>Indicates that no specific procedure for analyzing the data was found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; Data:
    &#34;&#34;&#34;
    Process the raw data of the element to extract meaningful information.

    This method should be overridden by subclasses to implement specific data extraction logic.

    Returns:
        Data: An instance of the Data class containing &#39;raw data&#39; as its content, with a comment indicating the absence of specific data extraction procedures.

    Raises:
        Warning: Indicates that no specific procedure for analyzing the data was found.
    &#34;&#34;&#34;
    warnings.warn(
        (f&#34;No procedure for analyzing the data found in type `{type(self)}`,&#34;
         f&#34;returning the raw data:\n{self.raw_data}&#34;)
    )
    return Data(data={&#39;raw data&#39;: self.raw_data},
                comment=(&#34;No procedure for analyzing the data found, `raw data` collected.\n&#34;
                         &#34;Please contribute to the project if you have knowledge on how to extract data from it.&#34;))</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Element.depth"><code class="name flex">
<span>def <span class="ident">depth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the depth of nested structures within the element.</p>
<p>This method recursively computes the maximum depth of nested lists representing the structure of the element.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The maximum depth of the element's structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth(self) -&gt; int:
    &#34;&#34;&#34;
    Calculate the depth of nested structures within the element.

    This method recursively computes the maximum depth of nested lists representing the structure of the element.

    Returns:
        int: The maximum depth of the element&#39;s structure.
    &#34;&#34;&#34;
    return Element.max_depth(self.get_structure())</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Element.get_structure"><code class="name flex">
<span>def <span class="ident">get_structure</span></span>(<span>self) ‑> dict[typing_extensions.Self, tuple | None]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the structural representation of the element.</p>
<p>The structure is intended as a nested list to represent hierarchical relationships within data.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary with the element itself as the key and an empty list as the value, indicating no nested structure by default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_structure(self) -&gt; dict[Self, tuple | None]:
    &#34;&#34;&#34;
    Retrieve the structural representation of the element.

    The structure is intended as a nested list to represent hierarchical relationships within data.

    Returns:
        A dictionary with the element itself as the key and an empty list as the value, indicating no nested structure by default.
    &#34;&#34;&#34;
    return [self, []]</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Element.readable_name"><code class="name flex">
<span>def <span class="ident">readable_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a readable name for the element.</p>
<p>This method should be implemented by subclasses to provide a meaningful name based on the element's data.</p>
<h2 id="returns">Returns</h2>
<p>None by default, indicating the method has not been implemented. Subclasses should override this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def readable_name(self):
    &#34;&#34;&#34;
    Generate a readable name for the element.

    This method should be implemented by subclasses to provide a meaningful name based on the element&#39;s data.

    Returns:
        None by default, indicating the method has not been implemented. Subclasses should override this.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="orcaparse.elements.Element.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an HTML representation of the element.</p>
<p>This method provides a basic HTML structure for displaying the element's data. Subclasses may override this method for more specialized HTML representations.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string containing the HTML representation of the element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_html(self) -&gt; str:
    &#34;&#34;&#34;
    Generate an HTML representation of the element.

    This method provides a basic HTML structure for displaying the element&#39;s data. Subclasses may override this method for more specialized HTML representations.

    Returns:
        str: A string containing the HTML representation of the element.
    &#34;&#34;&#34;
    data = self.raw_data
    is_block = isinstance(self, Block)
    line_start, line_finish = self.line_position or (-1, -1)
    return (f&#39;&lt;div class=&#34;element&#34; &#39;
            f&#39;python-class-name=&#34;{self.__class__.__name__}&#34; &#39;
            f&#39;start-line={line_start} finish-line={line_finish} &#39;
            f&#39;is-block=&#34;{is_block}&#34;&gt;\n{self.data_preformat(data)}&lt;/div&gt;&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="orcaparse.elements.ExtractionError"><code class="flex name class">
<span>class <span class="ident">ExtractionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom exception for energy extraction errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtractionError(Exception):
    &#34;&#34;&#34;Custom exception for energy extraction errors.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="orcaparse.elements.Spacer"><code class="flex name class">
<span>class <span class="ident">Spacer</span></span>
<span>(</span><span>raw_data: str, char_position: tuple[int, int] | None = None, line_position: tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an Element with raw data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw string data associated with this element.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spacer(Element):
    def data(self) -&gt; None:
        &#34;&#34;&#34;
        Override the data method to return None for a Spacer.

        Since a Spacer is intended to represent empty space or a separator, it does not contain meaningful data to be processed or extracted.

        Returns:
            None: Indicating that there is no data associated with this Spacer.
        &#34;&#34;&#34;
        return None

    @staticmethod
    def data_preformat(data_raw: str) -&gt; str:
        &#34;&#34;&#34;
        Format the raw body content for HTML display.

        Args:
            body_raw (str): The raw body text to be formatted.

        Returns:
            str: spacer with \\n replaced by &lt;br&gt;
        &#34;&#34;&#34;
        return data_raw.replace(&#39;\n&#39;, &#39;&lt;br&gt;&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="orcaparse.elements.Spacer.data_preformat"><code class="name flex">
<span>def <span class="ident">data_preformat</span></span>(<span>data_raw: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format the raw body content for HTML display.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>body_raw</code></strong> :&ensp;<code>str</code></dt>
<dd>The raw body text to be formatted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>spacer with \n replaced by <br></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def data_preformat(data_raw: str) -&gt; str:
    &#34;&#34;&#34;
    Format the raw body content for HTML display.

    Args:
        body_raw (str): The raw body text to be formatted.

    Returns:
        str: spacer with \\n replaced by &lt;br&gt;
    &#34;&#34;&#34;
    return data_raw.replace(&#39;\n&#39;, &#39;&lt;br&gt;&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="orcaparse.elements.Spacer.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Override the data method to return None for a Spacer.</p>
<p>Since a Spacer is intended to represent empty space or a separator, it does not contain meaningful data to be processed or extracted.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Indicating that there is no data associated with this Spacer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self) -&gt; None:
    &#34;&#34;&#34;
    Override the data method to return None for a Spacer.

    Since a Spacer is intended to represent empty space or a separator, it does not contain meaningful data to be processed or extracted.

    Returns:
        None: Indicating that there is no data associated with this Spacer.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a></b></code>:
<ul class="hlist">
<li><code><a title="orcaparse.elements.Element.depth" href="#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Element.get_structure" href="#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Element.max_depth" href="#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Element.process_invalid_name" href="#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Element.readable_name" href="#orcaparse.elements.Element.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Element.to_html" href="#orcaparse.elements.Element.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="orcaparse" href="index.html">orcaparse</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="orcaparse.elements.AvailableBlocksGeneral" href="#orcaparse.elements.AvailableBlocksGeneral">AvailableBlocksGeneral</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.elements.AvailableBlocksGeneral.blocks" href="#orcaparse.elements.AvailableBlocksGeneral.blocks">blocks</a></code></li>
<li><code><a title="orcaparse.elements.AvailableBlocksGeneral.register_block" href="#orcaparse.elements.AvailableBlocksGeneral.register_block">register_block</a></code></li>
<li><code><a title="orcaparse.elements.AvailableBlocksGeneral.rewrite_block" href="#orcaparse.elements.AvailableBlocksGeneral.rewrite_block">rewrite_block</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.elements.Block" href="#orcaparse.elements.Block">Block</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.elements.Block.body" href="#orcaparse.elements.Block.body">body</a></code></li>
<li><code><a title="orcaparse.elements.Block.body_preformat" href="#orcaparse.elements.Block.body_preformat">body_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.data_available" href="#orcaparse.elements.Block.data_available">data_available</a></code></li>
<li><code><a title="orcaparse.elements.Block.extract_name_header_and_body" href="#orcaparse.elements.Block.extract_name_header_and_body">extract_name_header_and_body</a></code></li>
<li><code><a title="orcaparse.elements.Block.header" href="#orcaparse.elements.Block.header">header</a></code></li>
<li><code><a title="orcaparse.elements.Block.header_preformat" href="#orcaparse.elements.Block.header_preformat">header_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Block.readable_name" href="#orcaparse.elements.Block.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Block.to_html" href="#orcaparse.elements.Block.to_html">to_html</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.elements.BlockUnknown" href="#orcaparse.elements.BlockUnknown">BlockUnknown</a></code></h4>
</li>
<li>
<h4><code><a title="orcaparse.elements.Element" href="#orcaparse.elements.Element">Element</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.elements.Element.data" href="#orcaparse.elements.Element.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Element.data_preformat" href="#orcaparse.elements.Element.data_preformat">data_preformat</a></code></li>
<li><code><a title="orcaparse.elements.Element.depth" href="#orcaparse.elements.Element.depth">depth</a></code></li>
<li><code><a title="orcaparse.elements.Element.get_structure" href="#orcaparse.elements.Element.get_structure">get_structure</a></code></li>
<li><code><a title="orcaparse.elements.Element.max_depth" href="#orcaparse.elements.Element.max_depth">max_depth</a></code></li>
<li><code><a title="orcaparse.elements.Element.process_invalid_name" href="#orcaparse.elements.Element.process_invalid_name">process_invalid_name</a></code></li>
<li><code><a title="orcaparse.elements.Element.readable_name" href="#orcaparse.elements.Element.readable_name">readable_name</a></code></li>
<li><code><a title="orcaparse.elements.Element.to_html" href="#orcaparse.elements.Element.to_html">to_html</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="orcaparse.elements.ExtractionError" href="#orcaparse.elements.ExtractionError">ExtractionError</a></code></h4>
</li>
<li>
<h4><code><a title="orcaparse.elements.Spacer" href="#orcaparse.elements.Spacer">Spacer</a></code></h4>
<ul class="">
<li><code><a title="orcaparse.elements.Spacer.data" href="#orcaparse.elements.Spacer.data">data</a></code></li>
<li><code><a title="orcaparse.elements.Spacer.data_preformat" href="#orcaparse.elements.Spacer.data_preformat">data_preformat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>